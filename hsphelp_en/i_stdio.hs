;
;	HSP help manager HELP source file
;	(Lines starting with ; are treated as comments)
;

%type
Built-in command
%ver
3.7
%note
ver3.7 standard command
%date
2023/08/25
%author
onitama
%url
http://hsp.tv/
%port
Win
Cli
Let

%index
getkey
Check key input
%group
Basic input/output control commands
%prm
p1,p2
p1=variable : Variable to read into
p2=1〜(1) : Key code

%inst
Checks the status of the keyboard and mouse buttons and assigns it to a variable.  If the specified button is pressed, 1 is assigned; otherwise, 0 is assigned.
The details of the values specified by the key code are as follows:
^p
  Key code : Actual key
 ------------------------------------------
        1    : Mouse left button
        2    : Mouse right button
        3    : Cancel ([CTRL]+[BREAK])
        4    : Middle button of a 3-button mouse
        8    : [BACKSPACE] (PC98's [BS])
        9    : [TAB]
       13    : [ENTER]
       16    : [SHIFT]
       17    : [CTRL]
       18    : [ALT] (PC98's [GRPH])
       20    : [CAPSLOCK]
       27    : [ESC]
       32    : Space key
       33    : [PAGEUP] (PC98's [ROLLDOWN])
       34    : [PAGEDOWN] (PC98's [ROLLUP])
       35    : [END] (PC98's [HELP])
       36    : [HOME] (PC98's [HOMECLR])
       37    : Cursor key [←]
       38    : Cursor key [↑]
       39    : Cursor key [→]
       40    : Cursor key [↓]
   48〜57    : [0]〜[9] (Main keyboard)
   65〜90    : [A]〜[Z]
  96〜105    : [0]〜[9] (Numeric keypad)
 112〜121    : Function keys [F1]〜[F10]
^p
Even keys that are not listed in this table may be obtainable. (You can check the key codes by running the sample.)

%sample
title "Please input a key (^^)v"
onkey *inkey
onclick *inkey
stop
*inkey
if lparam>>30:stop
mes wparam
stop

%href
stick

%index
mouse
Set mouse cursor coordinates
%group
Basic input/output control commands
%prm
p1,p2,p3
p1,p2 : X,Y coordinates to set
p3(0) : Setting mode value
%inst
Changes the mouse cursor to the coordinates specified by p1 and p2.
The coordinates specified are not coordinates within the window, but coordinates on the display (usually X=0 to ginfo_dispx/Y=0 to ginfo_dispy).
If the specifications of p1 and p2 are omitted, the current coordinates are applied as they are.
The setting mode regarding the display/non-display of the mouse cursor is determined by the value of p3. The value of p3 operates as follows.
^p
Mode value  Content
-------------------------------------------------------------------------
    0     Sets the mouse cursor to be hidden when the value of p1 or p2 is negative.
          Otherwise, moves the mouse cursor to the coordinates of (p1, p2) and displays it.
   -1     Moves the mouse cursor to the coordinates of (p1, p2) and sets it to be hidden.
    1     Moves the mouse cursor to the coordinates of (p1, p2) and maintains the display/non-display setting.
    2     Moves the mouse cursor to the coordinates of (p1, p2) and displays it if it is set to non-display.
^p
If the value of p3 is 0 (default value), the mouse cursor display is set to OFF (hidden) on the HSP window when p1 or p2 is a negative value.
After turning OFF the mouse cursor display, it will be displayed again by setting valid coordinates.
If the value of p3 is other than 0, coordinates can be specified regardless of the values of (p1, p2) and the ON/OFF of the mouse cursor. This is used when you need to handle negative coordinates in a multi-monitor environment, etc.

%port-
Let

%index
randomize
Initialize random number generation
%group
Basic input/output control commands
%prm
p1
p1=0〜(undefined) : Random number initialization parameter

%inst
Initializes the pattern of random numbers generated by the rnd function.
^
Random numbers initialized by specifying the same value for p1 can always be generated in the same pattern.
If p1 is omitted, it is initialized using an indefinite value obtained from the Windows timer. This allows you to generate completely different random numbers each time.

%href
rnd

%index
stick
Get key input information
%group
Basic input/output control commands
%prm
p1,p2,p3
p1=variable : Variable to read into
p2=0〜(0) : Non-trigger type key specification
p3=0〜1(1) : Window active check ON/OFF

%inst
Checks the status of frequently used keyboard and mouse buttons collectively and assigns it to a variable.
^
When the stick command is executed, the following button information is assigned to the variable specified by p1 as a single numeric value.
^p
Value (decimal) Value (hex) Key
-------------------------------------
     1  : $00001 : Cursor key left (←)
     2  : $00002 : Cursor key up (↑)
     4  : $00004 : Cursor key right (→)
     8  : $00008 : Cursor key down (↓)
    16  : $00010 : Space key
    32  : $00020 : Enter key
    64  : $00040 : Ctrl key
   128  : $00080 : ESC key
   256  : $00100 : Mouse left button
   512  : $00200 : Mouse right button
  1024  : $00400 : TAB key
  2048  : $00800 : [Z] key
  4096  : $01000 : [X] key
  8192  : $02000 : [C] key
 16384  : $04000 : [A] key
 32768  : $08000 : [W] key
 65536  : $10000 : [D] key
131072  : $20000 : [S] key
^p
0 is assigned if no buttons are pressed.
^
If multiple buttons are pressed simultaneously, all of those numeric values are added together.
For example, if the cursor key right and the space key are pressed simultaneously, 4+16=20 is read into the variable.
When checking this numeric value with an if command, the operator "&" is useful.
^p
Example:
	stick a,0            ; Read the key state into variable a
	if a&16 : goto *spc  ; Was the space key pressed?
	if a&32 : goto *ent  ; Was the Enter key pressed?
^p
In this way, "variable&key information" can be used to extract only one key information from the numeric value containing multiple button information.
^
The stick command is very similar to the getkey command, but the biggest difference is that it detects only the moment a button is pressed. In other words, it returns the pressed information only once when the button is pressed, and after that, it will not be considered pressed until the pressed button is released.
^
However, by specifying the non-trigger type key of p2, information can be detected even if the key is held down.
^
If you specify the code of a key that can be detected even when it is held down in p2 (the codes in the table above. If there are multiple keys, add the respective numeric values), then only that key will continue to be detected while the button is pressed.
^
This command seems very complicated, but it will be a very useful feature when creating scripts that use keys.
For example, think of a shooting game. Your aircraft must move continuously in the up, down, left, and right directions while the buttons are pressed. However, the missile launch button will not launch the next missile until it is pressed once and released.
In such a case, only the up, down, left, and right keys should be specified as non-trigger type keys, and all other keys should return information that is pressed only once.
^
Also, you can turn ON/OFF the function to disable input when the window is not active with p3.
If p3 is 1 or omitted, key input is disabled when the HSP window is not active.
If p3 is 0, key input is performed in all situations.

%href
getkey
jstick

%index
logmes
Send debug message
%group
HSP system control commands
%prm
"message"
"message" : Message to record in the log

%inst
Records the contents of "message" in the debug log when the debug window is displayed.
It can be used to check the contents of variables at a certain point in time, or for pass checks, etc.
You need to set the display mode of the debug window from the script editor, or display the debug window with the assert command.
If you want to record a log when assigning a variable, you can use the logmesv and logmesva commands.
This command is disabled when creating an executable file.

%href
logmesv
logmesva
assert
varprop

%index
logmesv
Variable debug message display settings
%group
HSP system control commands
%prm
var
var : Variable name to set debug message for
%inst
Sets the display of variable debug messages.
This allows you to record debug messages for the specified variable when the debug window is displayed.
Debug message display is enabled by specifying a variable in the var parameter. In this case, array variable elements 1 and later are not displayed. To enable debug message display for all elements of an array variable, use the logmesva command.
^
The following example sets debug message display for variable a.
^p
Example:
	logmesv a		; A debug message is displayed when variable a is assigned
^p
Variables for which debug message display is set will have a debug message recorded when their contents are changed, such as by assignment.
Variable debug messages are displayed as follows:
^p
#set[a=0] line:17 (test_logmes.hsp)
#set[b=456] line:22 (test_logmes.hsp)
#set[b(1)=123] line:22 (test_logmes.hsp)
#set[b(2)=789] line:22 (test_logmes.hsp)
#set[c="abcdefgh..."] line:23 (test_logmes.hsp)
^p
The "variable name=content" set after #set is displayed. Content display is only intended to be simple. Only the first 16 characters of a string are displayed.
Array variables are displayed as "variable name(element)", but note that array elements with two or more dimensions are treated as one dimension.
At the end, information about which line and script file the value was set in is recorded in the form "line:line number (script file)".
Variable debug messages can be used to check for mistakes such as the contents being unintentionally changed within the script, or not being assigned correctly.
^
To disable the display of debug messages set for a variable, use the varprop command. The varprop command can be used to change the settings of debug messages.
^
To display the debug window, you need to set the display mode of the debug window from the script editor, or display the debug window with the assert command.
Please note that this command is disabled in executable scripts and platform-converted environments (iOS, android).
%href
Please translate this text into English. This is an article about the programming language HSP3. Do not change lines starting with '%' or '^' absolutely. Do not delete parts of the text. Be sure to translate Japanese. Make sure no Japanese remains.
logmes
logmesva
assert
varprop


%index
logmesva
Array variable debug message display settings
%group
HSP System Control Commands
%prm
var
var   : The name of the variable for which to set the debug message
%inst
Sets the display settings for variable debug messages.
This allows you to record debug messages for the specified variable when the debug window is displayed.
Specifying a variable in the var parameter enables the display of debug messages.
This command operates similarly to the logmesv command. The difference between the logmesv command and this command is that debug message display is enabled for all elements of an array variable.
To record debug messages for variables that do not use arrays, use the logmesv command.
To display the debug window, you need to set the debug window display mode from the script editor, or display the debug window using the assert command.
Please note that this command is disabled in scripts that have been converted into executable files or in platform-converted environments (iOS, Android).
%href
logmes
logmesva
assert
varprop


%index
assert
Display debug window
%group
HSP System Control Commands
%prm
p1
p1(0) : Conditional expression for debugging

%inst
Temporarily interrupts the program and displays the debug window.
If a conditional expression is specified in p1, the debug window is displayed only when the condition in p1 is not true.
(Note that p1 should contain the conditional expression for when to pass through without debugging.)
^p
	assert a>5  ; Debug when a is 5 or less
^p
This command is disabled when creating executable files.

%href
logmes
logmesv
%port-
Let



%index
mcall
Method call
%group
Basic Input/Output Control Commands
%prm
p1,p2,p3…
p1 : Variable name
p2 : Method name
p3 : Parameter

%inst
Calls a method according to the type of variable specified in p1.
By specifying a COM object type for the variable in p1, it is possible to call COM automation methods.
Specify the method name (string) or dispatch ID (DISPID) in p2, and specify the arguments after p3.
The number of parameters and the type of parameters from p3 onward are converted appropriately and passed to the method.
The return value of the method execution is assigned to the variable set by the comres command.
Also, if the method execution is successful, the system variable stat becomes 0, and if an execution error occurs, the result code (HRESULT) is assigned to the system variable stat.

The mcall command can provide new functionality by providing extended variable types. Standard support is only available for COM object types.

%href
#usecom
newcom
delcom
querycom
comres
%port-
Let



%index
setease
Set easing function calculation formula
%group
Basic Input/Output Control Commands
%prm
p1,p2,p3
p1 : Minimum output value (real number)
p2 : Maximum output value (real number)
p3 : Calculation formula type value
%inst
Sets the easing function for interpolating numbers within a specified range using an arbitrary calculation formula.
The settings specified here are reflected when obtaining values using the easing functions (getease, geteasef).
The following can be specified as the calculation formula type value:
^p
	Macro name                Interpolation content
	------------------------------------------------------------
	ease_linear		Linear (linear interpolation)
	ease_quad_in		Acceleration (Quadratic)
	ease_quad_out		Deceleration (Quadratic)
	ease_quad_inout		Acceleration → Deceleration (Quadratic)
	ease_cubic_in		Acceleration (Cubic)
	ease_cubic_out		Deceleration (Cubic)
	ease_cubic_inout	Acceleration → Deceleration (Cubic)
	ease_quartic_in		Acceleration (Quartic)
	ease_quartic_out	Deceleration (Quartic)
	ease_quartic_inout	Acceleration → Deceleration (Quartic)
	ease_bounce_in		Bounce effect (in)
	ease_bounce_out		Bounce effect (out)
	ease_bounce_inout	Bounce effect (in/out)
	ease_shake_in		Shake effect (in)
	ease_shake_out		Shake effect (out)
	ease_shake_inout	Shake effect (in/out)
	ease_loop		Interpolation loop (*)

The type indicated by (*) can be added to other types.
^p
If the calculation formula type value is omitted, the previously set value is used as is.

Easing functions support basic calculations for obtaining natural motion animations.
For example, suppose an object with an X coordinate of 100 is moved to an X coordinate of 200 in an animation of 50 frames.
Normally, the animation would be created by adding 2 to the X coordinate for each frame, such as 100, 102, 104, 106, ... to obtain the new coordinate.
However, this only results in linear movement. Easing functions allow you to obtain the coordinates for each frame from a specific calculation formula.
Depending on the calculation formula settings, it is possible to achieve organic animations such as starting the movement slowly, accelerating during the movement, and decelerating again before the target, as well as various applications such as movements that draw parabolas and bounce, and movements that shake around.
To use easing functions, first specify the range in which the value changes and the calculation formula with the setease command.
^p
	;	Easing function settings
	setease 100,200,ease_cubic_inout
^p
In the above example, an easing function is set with the ease_cubic_inout calculation formula to obtain values from 100 to 200.
Next, obtain the actual value using the getease or geteasef function.
getease and geteasef are basically the same, but differ in whether the value obtained is an integer value or a real number value.
When handling normal coordinates, it is usually not a problem to obtain them as integer values. (Both internally use real number calculations in the easing function)
^p
	;	Easing function settings
	setease 100,200,ease_cubic_inout
	i=0
	repeat
		redraw 0
		color 0,0,0:boxf	; Clear the screen
		x = getease(i,50)	; Get easing value (integer)
		color 255,255,255
		pos x,100 : mes "●"
		redraw 1
		await 30
		i=i+1
	loop
^p
The argument of the getease function is getease(time elapsed value, maximum value).
The time elapsed value is an integer value starting from 0 and specifying up to the value specified by the maximum value.
In other words, in the above example, getease(0,50) returns the start value in the range of 100 to 200 set by the setease command, that is, 100.
As the time elapsed value increases, the value returned from 100 to 200 also increases. And, getease(50,50) becomes a calculation formula that returns 200.
^p
	When the time elapsed value is 0 = the minimum output value specified by the setease command is returned
	When the time elapsed value is the maximum value = the maximum output value specified by the setease command is returned
^p
If the maximum value parameter is omitted, 4096 is used.
In the case of the geteasef function as well, the argument is the same as geteasef(time elapsed value, maximum value).
However, both the time elapsed value and the maximum value can use real numbers, and the easing function can be used with finer precision. Also, if the maximum value parameter is omitted in the geteasef function, 1.0 is used.

Normally, if the time elapsed value is a negative value, it is regarded as 0. Also, if the time elapsed value exceeds the maximum value, it is also treated as the maximum value.
However, if ease_loop (interpolation loop) is added in the calculation formula type setting by the setease command, the interpolation loop (repetition) is performed including values outside the range. In the interpolation loop, the output minimum value and the output maximum value reciprocate according to the time elapsed value.

Easing functions may be difficult to imagine the results at first, but they are a convenient function that allows you to easily use advanced animation by mastering them.
Also, because it is a command built into the standard, it can be called in the same way in all runtimes such as HSP3Dish and HGIMG4.

%href
getease
geteasef
%port-
Let



%index
sortval
Sort array variables numerically
%group
Basic Input/Output Control Commands
%prm
p1,p2
p1 : Numeric array variable name
p2 : Sort order (0=ascending/1=descending)
%inst
Sorts (rearranges) an array variable containing numbers in the specified sort order.
The array variable specified in p1 is directly rearranged.

Information about sorting can be obtained using the sortget command.
%href
sortget
%port-
Let


%index
sortstr
Sort array variables alphabetically
%group
Basic Input/Output Control Commands
%prm
p1,p2
p1 : String array variable name
p2 : Sort order (0=ascending/1=descending)
%inst
Sorts (rearranges) an array variable containing strings in the specified sort order.
The array variable specified in p1 is directly rearranged.
The sort order is compared by the size of the ASCII code, so it is sorted in ABC order or あいうえお order.

Information about sorting can be obtained using the sortget command.
%href
sortget
%port-
Let



%index
sortnote
Sort memory note strings
%group
Basic Input/Output Control Commands
%prm
p1,p2
p1 : Variable name of string type in memory note format
p2 : Sort order (0=ascending/1=descending)
%inst
Sorts (rearranges) a variable containing a string in memory notepad format in the specified sort order.
The variable specified in p1 is directly rearranged.
The sort order is compared by the size of the ASCII code, so it is sorted in ABC order or あいうえお order.

Information about sorting can be obtained using the sortget command.
The memory notepad format is a string of data separated by "\n" (line feed code), which can be used with the notesel, noteget commands, etc.
%href
notesel
sortget
%port-
Let



%index
sortget
Get the index of the sort source
%group
Basic Input/Output Control Commands
%prm
p1,p2
p1 : Variable name where the result is assigned
p2 : Index No.
%inst
After executing the sortstr, sortval, or sortnote command, this command checks which index the stored data was placed in before sorting in the array and returns the result.
For example, if the array variable a is sorted and the command sortget n,4 returns a value of 1, it indicates that the value currently in the array variable a(4) was in a(1) before sorting.
This command is effective when sorting only a part of the data and rearranging other data based on that information.
%href
sortstr
sortval
sortnote
%port-
Let



%index
varprop
Set debug settings for variables
%group
HSP System Control Commands
%prm
var,p1
var   : Variable name to configure debugging settings
p1(0) : Debug setting value (varprop_*)
%inst
Configures debugging settings for variables.
This supports safer variable operation and bug detection by individually specifying type locking, value locking, and debugging log recording for the specified variable.
Specify the variable name in the var parameter, and the debug setting value in the p1 parameter. (Already set debug setting values will be maintained.)
You can use the following macros for debug setting values.
^p
	Macro Name        Value    Description
	------------------------------------------------------------
	varprop_xtype     1     Lock variable type
	varprop_xvalue    2     Lock variable value
	varprop_log       4     Enable variable debug logging
	varprop_logarray  8     Enable array variable debug logging
^p
Each value can be added together to specify multiple settings at the same time.
If "varprop_xtype" is set, the variable type will be locked. From this point on, the variable type will be prohibited from changing, and an error will occur if the variable type is changed during execution.
This is the same behavior as when the variable type is locked with the preprocessor instruction "#varint".
If "varprop_xvalue" is set, the variable value will be locked to the value that was assigned at that point. From this point on, an error will occur if the variable value is changed during execution.
This allows you to lock variable values and types, and detect unintended variable initialization or value overwrites.
If "varprop_log" or "varprop_logarray" is set, a variable debug message will be displayed in the debug window's log when a variable is assigned. This is the same function as the "logmesv" and "logmesva" commands. See the help for the logmesv command for details on variable debug messages.
If the p1 parameter is omitted or 0 is specified, all variable debug settings will be cleared.
^
The varprop command, like the assert command, provides support for debugging execution. Please note that this command is disabled in scripts that have been converted to executable files or in platform-converted environments (iOS, Android).
%href
logmesv
logmesva
#varint
assert
