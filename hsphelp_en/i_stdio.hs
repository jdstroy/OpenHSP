;
;	HELP source file for HSP help manager
;	(Lines starting with ; are treated as comments)
;

%type
Built-in command
%ver
3.7
%note
ver3.7 standard command
%date
2023/08/25
%author
onitama
%url
http://hsp.tv/
%port
Win
Cli
Let




%index
getkey
Check key input
%group
Basic input/output control commands
%prm
p1,p2
p1=Variable   : Variable to read into
p2=1Å`(1) : Key code

%inst
Checks the state of the keyboard and mouse buttons and assigns it to a variable. If the specified button is pressed, 1 is assigned; otherwise, 0 is assigned.
Details of the values specified by key code are as follows.
^p
  Key Code : Actual Key
 ------------------------------------------
        1    : Mouse left button
        2    : Mouse right button
        3    : Cancel ([CTRL]+[BREAK])
        4    : Middle button of 3-button mouse
        8    : [BACKSPACE] ([BS] on PC98)
        9    : [TAB]
       13    : [ENTER]
       16    : [SHIFT]
       17    : [CTRL]
       18    : [ALT] ([GRPH] on PC98)
       20    : [CAPSLOCK]
       27    : [ESC]
       32    : Space key
       33    : [PAGEUP] ([ROLLDOWN] on PC98)
       34    : [PAGEDOWN] ([ROLLUP] on PC98)
       35    : [END] ([HELP] on PC98)
       36    : [HOME] ([HOMECLR] on PC98)
       37    : Cursor key [Å©]
       38    : Cursor key [Å™]
       39    : Cursor key [Å®]
       40    : Cursor key [Å´]
   48Å`57    : [0]Å`[9] (Main keyboard)
   65Å`90    : [A]Å`[Z]
  96Å`105    : [0]Å`[9] (Numeric keypad)
 112Å`121    : Function keys [F1]Å`[F10]
^p
Even if the key is not listed in this table, it may be acquired. (You can check the key code by executing the sample.)


%sample
title "Please input a key (^^)v"
onkey *inkey
onclick *inkey
stop
*inkey
if lparam>>30:stop
mes wparam
stop


%href
stick




%index
mouse
Set mouse cursor coordinates
%group
Basic input/output control commands
%prm
p1,p2,p3
p1,p2 : X,Y coordinates to set
p3(0) : Setting mode value
%inst
Changes the mouse cursor to the coordinates specified by p1, p2.
The specified coordinates are not window-relative, but display-relative coordinates (usually X=0Å`ginfo_dispx/Y=0Å`ginfo_dispy).
If p1 and p2 are omitted, the current coordinates are applied as is.
The setting mode for mouse cursor display/hide is determined by the value of p3. The value of p3 operates as follows.
^p
Mode Value  Content
-------------------------------------------------------------------------
    0     Hides the mouse cursor when the value of p1 or p2 is negative.
          Otherwise, moves the mouse cursor to the (p1, p2) coordinates and displays it.
   -1     Moves the mouse cursor to the (p1, p2) coordinates and sets it to hidden.
    1     Moves the mouse cursor to the (p1, p2) coordinates and maintains the display/hide setting.
    2     Moves the mouse cursor to the (p1, p2) coordinates and displays it if it is set to hidden.
^p
If the value of p3 is 0 (default value), the mouse cursor display is set to OFF (hidden) on the HSP window when p1 or p2 is a negative value.
After the mouse cursor display is turned OFF, it will be displayed again by setting valid coordinates.
If the value of p3 is other than 0, the coordinates can be specified regardless of the values of (p1, p2) and the ON/OFF state of the mouse cursor. This is used when it is necessary to handle negative coordinate values in a multi-monitor environment, etc.

%port-
Let




%index
randomize
Initialize random number generation
%group
Basic input/output control commands
%prm
p1
p1=0Å`(Indefinite) : Random number initialization parameter

%inst
Initializes the pattern of random numbers generated by the rnd function.
^
Random numbers initialized with the same value for p1 can always be generated in the same pattern.
If p1 is omitted, initialization is performed using an indefinite value obtained from the Windows timer. This allows completely different random numbers to be generated each time.

%href
rnd




%index
stick
Acquire key input information
%group
Basic input/output control commands
%prm
p1,p2,p3
p1=Variable    : Variable to read into
p2=0Å`(0)  : Non-trigger type key specification
p3=0Å`1(1) : Window active check ON/OFF

%inst
Collectively checks the state of frequently used keyboard and mouse buttons and assigns them to a variable.
^
When the stick command is executed, the following button information is assigned to the variable specified by p1 as a single numerical value.
^p
Value (Decimal)  Value (Hex) Key
-------------------------------------
     1  : $00001 : Cursor key Left (Å©)
     2  : $00002 : Cursor key Up (Å™)
     4  : $00004 : Cursor key Right (Å®)
     8  : $00008 : Cursor key Down (Å´)
    16  : $00010 : Space key
    32  : $00020 : Enter key
    64  : $00040 : Ctrl key
   128  : $00080 : ESC key
   256  : $00100 : Mouse left button
   512  : $00200 : Mouse right button
  1024  : $00400 : TAB key
  2048  : $00800 : [Z] key
  4096  : $01000 : [X] key
  8192  : $02000 : [C] key
 16384  : $04000 : [A] key
 32768  : $08000 : [W] key
 65536  : $10000 : [D] key
131072  : $20000 : [S] key
^p
0 is assigned if no button is pressed.
^
If multiple buttons are pressed simultaneously, all of their values are added together.
For example, if the cursor key right and the space key are pressed simultaneously, 4+16=20 is read into the variable.
When checking this number with an if command or similar, the operator "&" is useful.
^p
Example :
	stick a,0            ; Read the key state into variable a
	if a&16 : goto *spc  ; Was the space key pressed?
	if a&32 : goto *ent  ; Was the Enter key pressed?
^p
In this way, "variable & key information" can be used to extract only one key information from a number containing multiple button information.
^
The stick command is very similar to the getkey command, but the biggest difference is that it detects only the moment a button is pressed. In other words, it returns information that a button is pressed only once when the button is pressed, and after that, it does not consider the button to be pressed until the pressed button is released.
^
However, by specifying a non-trigger type key for p2, it becomes possible to detect information even when it is held down.
^
If you specify the code of a key that will be detected even when held down in p2 (the code is in the table above. If there are multiple, add the respective values), that key will be detected continuously while the button is pressed.
^
This command may seem very complex, but it will be a very useful function when creating scripts that use keys.
For example, imagine a shooting game. Your aircraft must move continuously in the up, down, left, and right directions while the button is pressed. However, the missile launch button will not fire the next bullet until it is pressed once and released.
In such a case, you can specify only the up, down, left, and right keys as non-trigger type keys, and make the other keys return information that has been pressed only once.
^
Also, with p3, you can turn ON/OFF the function to disable input when the window is not active.
If p3 is 1 or omitted, key input is disabled if the HSP window is not active.
If p3 is 0, key input is performed in all situations.


%href
getkey
jstick



%index
logmes
Send debug message
%group
HSP system control commands
%prm
"message"
"message" : Message to record in the log

%inst
Records the contents of "message" in the debug log when the debug window is displayed.
It can be used to check the contents of variables at a certain point, or to check passage.
It is necessary to set the display mode of the debug window from the script editor, or to display the debug window with the assert command.
When recording a log when assigning a variable, you can use the logmesv and logmesva commands.
This command is disabled when creating an executable file.

%href
logmesv
logmesva
assert
varprop



%index
logmesv
Variable debug message display setting
%group
HSP system control commands
%prm
var
var   : Variable name to set the debug message
%inst
Sets the display of variable debug messages.
This allows you to record debug messages for the specified variable when the debug window is displayed.
By specifying a variable in the var parameter, the display of debug messages is enabled. In this case, elements 1 and later of the array variable will not be displayed. To enable the display of debug messages for all elements of an array variable, use the logmesva command.
^
In the following example, debug message display is set for variable a.
^p
Example :
	logmesv a		; A debug message is displayed when variable a is assigned
^p
Debug messages are recorded for variables for which debug message display is set when the content is changed by assignment or the like.
Variable debug messages are displayed as follows.
^p
#set[a=0] line:17 (test_logmes.hsp)
#set[b=456] line:22 (test_logmes.hsp)
#set[b(1)=123] line:22 (test_logmes.hsp)
#set[b(2)=789] line:22 (test_logmes.hsp)
#set[c="abcdefgh..."] line:23 (test_logmes.hsp)
^p
"#set" is followed by "variable name=content". The content display is only a simplified one. Only the first 16 characters of a string are displayed.
Array variables are displayed as "variable name(element)", but note that array elements of 2 or more dimensions are treated as 1 dimension.
At the end, information is recorded in the form "line:line number (script file)" about which line and script file the value was set in.
Variable debug messages allow you to check for mistakes such as unintentionally changing the contents of a script or not assigning correctly.
^
To disable the display of debug messages set for a variable, use the varprop command. The varprop command allows you to change the debug message settings.
^
To display the debug window, you need to set the display mode of the debug window from the script editor, or display the debug window with the assert command.
Please note that this command is disabled in scripts converted to executable files or in platform-converted environments (iOS, android).
%href
logmesva
assert
varprop
var
var   : Name of the variable to set debug messages for
%inst
Sets the display settings for variable debug messages.
This allows you to record debug messages for the specified variable when the debug window is displayed.
Specifying a variable in the var parameter enables the display of debug messages.
This command operates similarly to the logmesv command. The difference from the logmesv command is that debug message display is enabled for all elements of an array variable.
To record debug messages for variables that do not use arrays, use the logmesv command.
To display the debug window, you need to set the debug window display mode from the script editor or display the debug window using the assert command.
Please note that this command is disabled in scripts converted to executable files or in platform-converted environments (iOS, Android).
%href
logmes
logmesva
assert
varprop

%index
assert
Display debug window
%group
HSP system control command
%prm
p1
p1(0) : Conditional expression for debugging

%inst
Temporarily interrupts the program and displays the debug window.
If a conditional expression is specified in p1, the debug window is displayed only if the condition in p1 is not met.
(Note that p1 should contain the condition that must be met for the program to proceed).
^p
	assert a>5  ; Debug when a is 5 or less
^p
This command is disabled when creating executable files.

%href
logmes
logmesv
%port-
Let

%index
mcall
Call method
%group
Basic input/output control command
%prm
p1,p2,p3Åc
p1 : Variable name
p2 : Method name
p3 : Parameter

%inst
Calls a method according to the type of variable specified by p1.
By specifying a COM object type for the variable p1, it is possible to call COM automation methods.
Specify the method name (string) or dispatch ID (DISPID) in p2, and specify the arguments in p3 and later.
The number and type of parameters from p3 onwards are appropriately converted and passed to the method.
The return value of the method execution is assigned to the variable set by the comres command.
Also, if the method execution is successful, the system variable stat becomes 0, and if an execution error occurs, the result code (HRESULT) is assigned to the system variable stat.

The mcall command can provide new functions by preparing extended variable types. It supports only COM object types by default.

%href
#usecom
newcom
delcom
querycom
comres
%port-
Let

%index
setease
Set the easing function calculation formula
%group
Basic input/output control command
%prm
p1,p2,p3
p1 : Minimum output value (real number)
p2 : Maximum output value (real number)
p3 : Calculation formula type value
%inst
Sets the easing function to interpolate a number within a defined range using an arbitrary calculation formula.
The settings specified here are reflected when obtaining values with the easing functions (getease, geteasef).
The following can be specified for the calculation formula type value:
^p
	Macro Name                Interpolation Content
	------------------------------------------------------------
	ease_linear		Linear (linear interpolation)
	ease_quad_in		Acceleration (Quadratic)
	ease_quad_out		Deceleration (Quadratic)
	ease_quad_inout		Acceleration Å® Deceleration (Quadratic)
	ease_cubic_in		Acceleration (Cubic)
	ease_cubic_out		Deceleration (Cubic)
	ease_cubic_inout	Acceleration Å® Deceleration (Cubic)
	ease_quartic_in		Acceleration (Quartic)
	ease_quartic_out	Deceleration (Quartic)
	ease_quartic_inout	Acceleration Å® Deceleration (Quartic)
	ease_bounce_in		Bounce effect (in)
	ease_bounce_out		Bounce effect (out)
	ease_bounce_inout	Bounce effect (in/out)
	ease_shake_in		Shake effect (in)
	ease_shake_out		Shake effect (out)
	ease_shake_inout	Shake effect (in/out)
	ease_loop		Loop of interpolation (*)

The types indicated by (*) can be added to other types.
^p
If the calculation formula type value is omitted, the previously set value is used as is.

Easing functions support basic calculations for achieving natural motion animations.
For example, suppose you want to move an object with an X coordinate of 100 to an X coordinate of 200 in a 50-frame animation.
Normally, the animation would be created by adding 2 to the X coordinate in each frame, such as 100, 102, 104, 106, and so on, to obtain the new coordinate.
However, this only results in linear motion. Easing functions allow you to obtain the coordinate for each frame from a specific calculation formula.
Depending on the setting of the calculation formula, you can achieve organic animations such as starting to move slowly, accelerating while moving, and decelerating again in front of the target, as well as various other uses such as movements that draw parabolas and bounce, or movements that shake.
To use easing functions, first specify the range in which the value changes and the calculation formula with the setease command.
^p
	;	Easing function settings
	setease 100,200,ease_cubic_inout
^p
In the above example, an easing function for obtaining values from 100 to 200 is set using the ease_cubic_inout calculation formula.
Next, obtain the actual value using the getease or geteasef function.
getease and geteasef are basically the same, but the difference is whether the obtained value is an integer value or a real number value.
When handling normal coordinates, there is no problem even if you obtain them as integer values. (Both use real number calculations internally in the easing function.)
^p
	;	Easing function settings
	setease 100,200,ease_cubic_inout
	i=0
	repeat
		redraw 0
		color 0,0,0:boxf	; Clear the screen
		x = getease(i,50)	; Get the easing value (integer)
		color 255,255,255
		pos x,100 : mes "Åú"
		redraw 1
		await 30
		i=i+1
	loop
^p
The argument of the getease function is getease(elapsed time value, maximum value).
The elapsed time value is an integer value starting from 0, and specifies a value up to the value specified by the maximum value.
In other words, in the above example, getease(0,50) returns the start value in the range from 100 to 200 set by the setease command, that is, 100.
As the elapsed time value increases, the value returned from 100 to 200 also increases. And when it becomes getease(50,50), it is a calculation formula that returns 200.
^p
	When the elapsed time value is 0 = the minimum output value specified by the setease command is returned
	When the elapsed time value is the maximum value = the maximum output value specified by the setease command is returned
^p
If the maximum value parameter is omitted, 4096 is used.
In the case of the geteasef function, the argument is the same as geteasef(elapsed time value, maximum value).
However, real numbers can be used for both the elapsed time value and the maximum value, and the easing function can be used with finer accuracy. Also, if the maximum value parameter is omitted with the geteasef function, 1.0 is used.

Normally, if the elapsed time value is a negative value, it is regarded as 0. Also, if the elapsed time value exceeds the maximum value, it is treated as the maximum value.
However, if ease_loop (interpolation loop) is added to the calculation formula type setting by the setease command, the interpolation loop (repetition) is performed including values outside the range. In the interpolation loop, the minimum output value and the maximum output value move back and forth according to the elapsed time value.

Easing functions may be difficult to imagine the result at first, but they are a convenient feature that allows you to easily use advanced animations by mastering them.
Also, because it is a command built into the standard, it can be called in the same way in all runtimes such as HSP3Dish and HGIMG4.

%href
getease
geteasef
%port-
Let

%index
sortval
Sort array variables numerically
%group
Basic input/output control command
%prm
p1,p2
p1 : Name of the numeric array variable
p2 : Sort order (0=ascending/1=descending)
%inst
Sorts (rearranges) an array variable containing numbers in the specified sort order.
The array variable specified by p1 is directly rearranged.

Information about the sort can be obtained with the sortget command.
%href
sortget
%port-
Let

%index
sortstr
Sort array variables by string
%group
Basic input/output control command
%prm
p1,p2
p1 : Name of the string array variable
p2 : Sort order (0=ascending/1=descending)
%inst
Sorts (rearranges) an array variable containing strings in the specified sort order.
The array variable specified by p1 is directly rearranged.
The sort order is compared based on the larger and smaller ASCII codes, so it is sorted in ABC order or in alphabetical order.

Information about the sort can be obtained with the sortget command.
%href
sortget
%port-
Let

%index
sortnote
Sorts the memory notepad string
%group
Basic input/output control command
%prm
p1,p2
p1 : Variable name of the string type in memory notepad format
p2 : Sort order (0=ascending/1=descending)
%inst
Sorts (rearranges) a variable containing a string in memory notepad format in the specified sort order.
The variable specified by p1 is directly rearranged.
The sort order is compared based on the larger and smaller ASCII codes, so it is sorted in ABC order or in alphabetical order.

Information about the sort can be obtained with the sortget command.
Memory notepad format is a sequence of data separated by "\n" (line feed code) that can be used with the notesel, noteget commands, etc.
%href
notesel
sortget
%port-
Let

%index
sortget
Get the index of the sort source
%group
Basic input/output control command
%prm
p1,p2
p1 : Variable name where the result is assigned
p2 : Index No.
%inst
After executing the sortstr, sortval, or sortnote command, this command examines which index the stored data was located in before sorting in the array, and returns the result.
For example, if the value 1 is returned by the command sortget n,4 after sorting the array variable a, it indicates that the value currently in the array variable a(4) was in a(1) before sorting.
This command is effective when sorting only a part of the data and using that information to rearrange other data.
%href
sortstr
sortval
sortnote
%port-
Let

%index
varprop
Performs variable debug settings
%group
HSP System Control Command
%prm
var,p1
var   : Variable name to set debug settings
p1(0) : Debug setting value (varprop_*)
%inst
Sets debug settings for a variable.

This supports safer variable operation and bug detection by individually specifying type fixing, value fixing, and debug log recording for the specified variable.

Specify the variable name in the var parameter, and specify the debug setting value in the p1 parameter. (Already set debug setting values will be maintained.)

The following macros can be used for debug setting values.
^p
	Macro Name         Value     Setting Content
	------------------------------------------------------------
	varprop_xtype     1     Fixes the variable type
	varprop_xvalue    2     Fixes the variable value
	varprop_log       4     Enables variable debug logging
	varprop_logarray  8     Enables array variable debug logging
^p
Each value can be added together to specify multiple settings simultaneously.

If "varprop_xtype" is set, the variable type will be fixed. After this, the variable type will be prohibited from changing, and an error will occur if the variable type is changed during execution.

This works the same way as fixing a variable type with the preprocessor directive "#varint".

If "varprop_xvalue" is set, the variable value will be fixed to the value assigned at that point. After this, an error will occur if the variable value is changed during execution.

This allows you to fix variable values and types, and discover unintended variable initialization or value overwrites.

If "varprop_log" or "varprop_logarray" is set, variable debug messages will be displayed in the debug window's log when the variable is assigned a value. This is the same as the "logmesv" and "logmesva" commands. See the help for the logmesv command for details on variable debug messages.

If the p1 parameter is omitted or set to 0, all variable debug settings will be cleared.
^
The varprop command, like the assert command, provides assistance during debug execution. Please note that this command is disabled in scripts that have been converted to executable files or in platform-converted environments (iOS, Android).
%href
logmesv
logmesva
#varint
assert
