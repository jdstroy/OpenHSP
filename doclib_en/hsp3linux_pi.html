<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta http-equiv="Content-Language" content="en">
	<meta http-equiv="Content-Style-Type" content="text/css">
	<meta http-equiv="Content-Script-Type" content="text/javascript">
	<meta name="author" content="OpenHSP3 Project">
	<meta name="keywords" content="HSP3,HotSoupProcessor,Linux,Raspberry Pi">
	<meta name="description" content="HSP3に関するドキュメントの一覧">
	<link href="../main.css" rel="stylesheet" type="text/css" media="all">
	<title>HSP3 for Linux/Raspberry Pi</title>
</head>
<body>
	<div id="CONTAINER">
		<!-- Header -->
		<p id="COPY">HSP : Hot Soup Processor ver3.7 / onion software 1997-2025(c)</p>
		<h1>HSP3 for Linux/Raspberry Pi</h1>
		
		<!-- Main content -->

		<h2 id="BRIEF">Introduction</h2>
		<p>
		HSP3 for Linux/Raspberry Pi is a development environment for Hot Soup Processor (HSP) that runs on Linux GUI environment (X Window System) and Raspberry Pi (Raspbian).<br>
		Development is underway with the aim of supporting the HSP3 development environment on Linux, which is inexpensive and has a widely established environment.
		<a href="https://www.raspberrypi.org/" target="_blank">Raspberry Pi</a>, among them, is attracting attention in the fields of IoT and programming education as a very compact and inexpensive device.<br>
		Until now, we have developed execution environments such as Android, iOS, and WebGL (html5) through the <a href="hsp3dish.html" target="_blank">HSP3Dish</a> runtime, not only Windows, but also
		We will be developing a new environment that can be used on Linux and Raspbian (the OS on Raspberry Pi) environments.
		<br>
		<br><img src="image/hsp_pi.jpg"><br><br>
		As the first version, we have released a preview version that includes a simple script editor and the HSP3Dish/HGIMG4 execution environment.
		We plan to expand support along with the Windows version of HSP3, so please look forward to it.
		<br>
		<br>
		The latest version is available on github along with the source code.<BR>
		If you are using Raspberry Pi, the introduction is explained on <a href="https://junji.jp/hsp/" target="_blank">JBOYSOFT's "Beginner's Guide to HSP Programming Raspberry Pi Edition"</a> page.
		<br>
		<br>
		</p>

								<table>
									<tr>
										<td><img src="image/btn_next.gif" alt="" height="29" width="29" border="0"></td>
										<td><font size="-1"><a href="https://junji.jp/hsp/" target="_blank">Beginner's Guide to HSP Programming Raspberry Pi Edition by JBOYSOFT</a></font></td>
									</tr>
								</table>
								<br clear="all">

		<h2 id="DATA">Linux Installation</h2>
		<p>
		It operates in the Linux GUI environment (X Window System). Some functions operate using OpenGL and SDL libraries.
		If you can connect to the network, get the repository directly with the git command.
		</p><pre>
	git clone http://github.com/onitama/OpenHSP
		</pre><p>
		If there is an archive, extract the contents to any directory and compile the source. Compilation requires an environment in which gcc and make can be executed.
When compiling, the following libraries are required, so please check in advance.
		</p><pre>
	OpenGLES2.0 or later / EGL
	SDL2 / SDL2-mixer
	gtk+-2
	libcurl4
	libgpiod2
	libffi
		</pre><p>
In the case of Debian (Ubuntu), you can execute the following script to compile.
		</p><pre>
	./setup.sh
		</pre><p>
If you want to make manually, install the library from the package manager as follows. (In the case of Debian (Ubuntu))
		</p><pre>
	sudo apt update
	sudo apt install libgtk2.0-dev
	sudo apt install libglew-dev
	sudo apt install libsdl2-dev libsdl2-image-dev libsdl2-mixer-dev libsdl2-ttf-dev
	sudo apt install libgles2-mesa-dev libegl1-mesa-dev
	sudo apt install libcurl4-openssl-dev
	sudo apt install libgpiod2 libgpiod-dev
	sudo apt install -y libffi-dev
		</pre><p>
Since the repository only contains the source, it must be compiled by make.
(If it is not compiled correctly depending on the Linux version or distribution, it needs to be modified.)
		</p><pre>
	cd OpenHSP
	make
		</pre><p>
The necessary tools will be compiled, and HSP3 will be ready for use.
		</p>


		<h2 id="DATA">Raspberry Pi Installation</h2>
		<p>
		<img src="image/hsp_pi2.jpg" align="right">
		It operates on Raspberry Pi, Raspberry Pi2, Raspberry Pi3, Raspberry Pi400, Raspberry Pi4, Raspberry Pi5, Raspberry Pi zeo.<br>
		It operates on Raspberry Pi OS, Raspbian OS. Please use it with Raspbian running and the keyboard and mouse connected in advance.
		<br>
		
		<br>
		hsp3dish and hsp3gp (HGIMG4), hsed (script editor) only operate in the GUI environment.<br>		
		Extract the latest version from github to any directory and compile the source. Compilation requires an environment in which gcc and make can be executed.
		</p><pre>
	git clone http://github.com/onitama/OpenHSP
	cd OpenHSP
		</pre><p>
When compiling, additional libraries are required. You need to download the library while connected to the network.
	In the case of Raspberry Pi OS, the setup is executed by executing the following command.

		</p><pre>
	./setup.sh
		</pre><p>
	In the case of Raspbian OS in the environment of Raspberry Pi3 or less, the setup is executed by executing the following command.
		</p><pre>
	./pisetup.sh
		</pre><p>
Since the archive only contains the source, it must be compiled by make.
(If it is not compiled correctly depending on the Raspbian version or distribution, it needs to be modified.)
		</p><pre>
	make -f makefile.raspbian
		</pre><p>
Execute the make command in the directory where the contents of the archive are extracted.
The necessary tools will be compiled, and HSP3 will be ready for use.<br>
		</p><pre>
※ For Raspberry Pi4 and later, install it in the same way as Linux.
※ Full-screen execution is not supported on Raspberry Pi4 and later.
		</pre>

		<h2 id="DATA">How to Use</h2>
		<p>
		The following commands are generated when installation is performed.
		</p><pre>
	hsed		Script editor (simple version)
	hspcmp		HSP3 code compiler
	hsp3cl		HSP3 command line runtime
	hsp3dish	HSP3Dish runtime
	hsp3gp		HGIMG4 runtime
		</pre><p>
The script editor (simple version) is a GUI application that allows you to write and execute HSP3 scripts.
It has basic script editing, loading, and saving functions.
It can be started with the following command.
		</p><pre>
	./hsed
		</pre><p>
You can execute the script you are editing by selecting "Run" from the [F5] key or the "HSP" menu.
In the current version, hsp3dish is used as the standard runtime.
Sample code corresponding to HSP3Dish is included in the sample folder, so please try it.
The character code of the script is treated as UTF-8. Please note that this is different from the character code (SJIS) used by Windows.
		<br><br>
To execute a script from the command line, you need to create an HSP object file with hspcmp.
		</p><pre>
	./hspcmp -d -i -u test.hsp
		</pre><p>
In the above example, the object file "test.ax" is generated from the "test.hsp" file.
Pass the generated object file to the runtime for execution.
		</p><pre>
	./hspcmp -e test.ax
		</pre><p>
In the above example, "test.ax" is executed by the HSP3 command line runtime "hsp3cl".
Similarly, you can execute scripts that match runtimes such as "hsp3dish" and "hsp3gp".
(Executing "hsp3dish" and "hsp3gp" requires a GUI environment.)
		<br><br>
On the Raspberry Pi version, it will be executed in full screen. To interrupt the execution, press [ctrl] + [C] or [esc] key. Please note that interruption may not be possible if the keyboard is not recognized correctly. You can also execute it from the command line in the form of "./hsp3dish ****.ax" as well as the GUI editor.
		</p>
		<table>
				<tr>
					<td><img src="image/btn_next.gif" alt="" height="29" width="29" border="0"></td>
					<td><font size="-1"><a href="hsp3dish.html">To HSP3Dish page</a></font></td>
				</tr>
				<tr>
					<td><img src="image/btn_next.gif" alt="" height="29" width="29" border="0"></td>
					<td><font size="-1"><a href="http://www.onionsoft.net/hsp/v36/hsp3dish.htm">HSP3Dish Online Manual</a></font></td>
				</tr>
			</table>
		<br clear="all">


		<h2 id="DATA">About exec and devprm commands</h2>
		<p>
		Both Linux and Raspberry Pi versions can call shell commands using the exec command. Also, you can output a string to a device on the file system using the devprm command.
		</p><pre>
	devprm "/sys/class/gpio/export", "2"
		</pre><p>
		If you write like this, "2" will be output to "/sys/class/gpio/export". This is the same operation as executing "echo 2 > /sys/class/gpio/export" from the shell.
		</p>


		<h2 id="DATA">GPIO Input/Output</h2>
		<p>
		Extensions have been made to perform GPIO input/output using the devcontrol (gpio) command.<br>
		To control the GPIO output, write as follows.
		</p><pre>
	devcontrol "gpio", port number, output value
	( You can also write "gpio port number, output value" )
		</pre><p>
		The port number specifies the GPIO port as a number.
		The output value controls the output of the digital port by specifying 1 (ON) or 0 (OFF) as a number.
		To perform input, write as follows.
		</p><pre>
	devcontrol "gpioin", port number
	( It can also be written as a function as "gpioin(port number)" )
		</pre><p>
		After the command is executed, 0 or 1 is assigned to the system variable stat.
		(If an error occurs, a negative value is assigned.)<br>
		GPIO input/output can be used not only from hsp3dish but also from hsp3cl.
		</p>


		<h2 id="DATA">I2C Input/Output</h2>
		<p>
		Extensions have been made to perform input/output with I2C devices using the devcontrol (i2c〜) command.<br>
		(On Raspberry Pi, you need to enable I2C in the option settings. If you do not perform I2C control, you do not need to configure the settings.)<br>
		To perform I2C control, write as follows.
		</p><pre>
	devcontrol "i2copen", slave address, channel
	(You can also write "i2copen slave address, channel")

	"Channel" is a number used to identify multiple devices when specifying them simultaneously. (Integer value from 0 to 31)
	If you are controlling a single device, you can omit it (0).
	i2copen allows you to control the device at the specified address.
	The result is returned to the system variable stat. 0 indicates success, and anything else indicates an error.
		</pre><p>
		To output data, write as follows.
		</p><pre>
	devcontrol "i2cwrite", data value, data size, channel
	(You can also write "i2cwrite data value, data size, channel")

	The data value is a 32-bit integer value handled by HSP.
	If the data size is 0 or omitted, only 8 bits (1 byte) will be output.
	The data size can be specified as 1, 2, 3, or 4. Each will output a size of 1 to 4 bytes.
		</pre><p>
		To input data, write as follows.
		</p><pre>
	devcontrol "i2cread", channel
	(You can also write it as a function: "i2cread(channel)")

	devcontrol "i2creadw", channel
	(You can also write it as a function: "i2creadw(channel)")
		</pre><p>
After executing the command, the result is assigned to the system variable stat. i2cread gets an 8-bit (1 byte) value, and i2creadw gets a 16-bit (2 byte) value. (If an error occurs, a negative value is assigned.) I2C control can be used not only from hsp3dish but also from hsp3cl.
		</p>


		<h2 id="DATA">GPIO Input/Output</h2>
		<p>
		Extensions have been made to perform GPIO input/output using the devcontrol(gpio) command.<br>
		To control GPIO output, write as follows.
		</p><pre>
	devcontrol "gpio", port number, output value
	(You can also write "gpio port number, output value")
		</pre><p>
		The port number specifies the GPIO port as a numerical value.
		The output value controls the output of the digital port by specifying 1 (ON) or 0 (OFF) as a numerical value.
		To perform input, write as follows.
		</p><pre>
	devcontrol "gpioin", port number
	(You can also write it as a function: "gpioin(port number)")
		</pre><p>
		After executing the command, 0 or 1 is assigned to the system variable stat.
		(If an error occurs, a negative value is assigned.)<br>
		GPIO input/output can be used not only from hsp3dish but also from hsp3cl.
		</p>


		<h2 id="DATA">SPI Input/Output</h2>
		<p>
		Extensions have been made to perform SPI full-duplex communication using the devcontrol(spi) command.<br>
		SPI support up to HSP3.6 was limited to read/write system calls,
		therefore only half-duplex communication was supported (full-duplex communication is not possible with read/write).
		However, SPI has two data lines, and some SPI devices require communication via full-duplex communication.
		To exchange complete data, IOCTL based full-duplex communication is required.<br>
		In HSP3.7, a general-purpose and full-duplex communication (via IOCTL) capable SPI interface that can be accessed from HSP scripts will be added. In addition, a function to set the parameter `struct spi_ioc_transfer` required when requesting full-duplex communication (`SPI_IOC_MESSAGE(N)`) with IOCTL has also been added.<br>
		SPI control can be used not only from hsp3dish but also from hsp3cl.
		(When performing SPI control on Raspberry Pi, you need to enable SPI in the option settings. If you do not perform SPI control, you do not need to configure it.)<br>
		The basic commands are as follows.
		</p><pre>
	devcontrol "spiopen", bus number, chip select, ch number
	( open ch )
		</pre><p>
		"ch number" is a number used to identify multiple devices when specifying them simultaneously. (Integer value from 0 to 31)
		If you are controlling a single device, you can omit it (0).
		The bus number select and chip select correspond to the device file path <code>/dev/spidev&lt;bus number&gt;.&lt;chip select&gt;</code>,
		and you will be able to control the device corresponding to the specified device file.
		The result is returned to the system variable stat. 0 indicates success, and anything else indicates an error.
		</p><pre>
	devcontrol "spiclose", ch number
	( open ch )
		</pre><p>
		Ends communication for the specified channel.
		</p><pre>
	devcontrol "spiread", ch number
	( byte read )
	devcontrol "spiread", ch number
	( word read )
		</pre><p>
		After executing the command, the input value is assigned to the system variable stat.
		(If an error occurs, a negative value is assigned)
		</p><pre>
	devcontrol "spiwrite", output value, ch number
	( byte write )
	devcontrol "spiwritew", output value, ch number
	( word write )
		</pre><p>
		The output value is output to SPI.
		(If an error occurs, a negative value is assigned)
		</p>
		<p>
		The full-duplex communication commands are as follows.
		</p><pre>
	devcontrol "spitransceive", data value, data size, ch number
		The data value is a 32-bit integer value handled by HSP.
		If the data size is 0 or omitted, only 8 bits (1 byte) will be output.
		The data size can be specified as 1, 2, or 3. Each will transmit and receive a size of 1 to 3 bytes.
		Transmission and reception occur simultaneously.
		After executing the command, the received data of the specified size is assigned to the system variable stat as the result.
		(If an error occurs, a negative value is assigned).
		When used in a big-endian environment, the upper 3 bytes represent data and the lower 1 byte represents an error.
		</pre><p>
		If configuration is required for the SPI device driver, use <code>spiconfigureh</code>, <code>spiconfighrem</code>, <code>spiconfigurel</code>,
		in addition to <code>spisetmode</code>, <code>spisetmode32</code>, <code>spisetlsbfirst</code>,
		<code>spisetbitsperword</code>, and <code>spisetmaxspeedhz</code>.
		Each is written as follows.
		</p><pre>
	devcontrol "spiconfigureh", SPEED_HZ, DELAY_USECS, BITS_PER_WORD
	devcontrol "spiconfighrem", CS_CHANGE, TX_NBITS, RX_NBITS
	devcontrol "spiconfighrel", WORD_DELAY_USECS
	devcontrol "spisetmode", MODE, channel
	devcontrol "spisetmode32", MODE, channel
	devcontrol "spisetlsbfirst", LSB_FIRST, channel
	devcontrol "spisetbitsperword", BITSPERWORD, channel
	devcontrol "spisetmaxspeedhz", SPEED_HZ, channel
		<code>SPEED_HZ</code> sets the clock frequency.
		Setting <code>DELAY_USECS</code> to a non-zero value inserts a delay in microseconds between the transmission of the last bit and the transmission of the next byte.
		<code>BITS_PER_WORD</code> sets the word size of the device.
		Setting <code>CS_CHANGE</code> to a non-zero value does not deactivate the chip select after communication.
		<code>TX_NBITS</code> specifies the number of data lines for writing. 0 for single mode.
		When setting to dual or quad mode, set the value that <code>SPI_TX_DUAL</code>,
		<code>SPI_TX_QUAD</code> refer to from the host header.
		<code>RX_NBITS</code> specifies the number of data lines for reading. 0 for single mode.
		When setting to dual or quad mode, set the value that <code>SPI_RX_DUAL</code>,
		<code>SPI_RX_QUAD</code> refer to from the host header.
		<code>WORD_DELAY_USECS</code> sets the delay between words in microseconds.
		Setting <code>MODE</code> to 0&mdash;3 sets the SPI operating mode to mode 0, ..., mode 3 respectively.
		Setting <code>LSB_FIRST</code> to zero sets MSB first mode, and setting it to non-zero sets LSB first mode.
		</pre>
		<p>
		Example of SPI communication and initialization:
		</p>
		<pre>
	; Configure spidev options
	devcontrol "spisetmaxspeedhz", 10000, ch
	devcontrol "spisetmode", 0, ch
	devcontrol "spisetlsbfirst", 0, ch
	devcontrol "spisetbitsperword", 8, ch
	devcontrol "spiconfigureh", 10000, 0, 8
	devcontrol "spiconfigurem", 1, 0, 0	; Keep selecting the device for the 3-bytes command
	devcontrol "spiconfigurel", 0
	
	; Start communication
	;; Prepare a buffer as {dont care, upper 2 bits of data, lower 8 bits of data}
	dim recv, 3
	;; Send start byte
	devcontrol "spitransceive", 1, 1, ch
	byte(0) = stat
	;; Send control byte: SINGLE_ENDED (0x80) | adc_pin.
	;; In bit-wire sepresentation, {single/diff, adc_pin[2], adc_pin[1], adc_pin[0], x, x, x}
	SIGNLE_ENDED = 0x80
	devcontrol "spitransceive", SINGLE_ENDED | (adc_pin &lt;&lt; 4), 1, ch
	byte(1) = stat
	;; Send an empty byte (avoiding start byte 0x01) and receive rest data.
	devcontrol "spiconfigurem", 0, 0, 0	; Deselect the device
	devcontrol "spitransceive", 0x00, 1, ch
	byte(2) = stat
	res = ((0x03 & byte(1)) &lt;&lt; 8) | byte(2)
	mes res
		</pre>

		<h2 id="COPYRIGHT">Copyright and License</h2>
		<p>
		The Linux/Raspberry Pi version is treated as a derivative of OpenHSP, and the license is also a modified BSD license based on OpenHSP/HSP3.
		</p>
		<pre>
-------------------------------------------------------------------------------
Hot Soup Processor (HSP)
Copyright (C) 1997-2021, Onion Software/onitama, all rights reserved.
Made with base technology of OpenHSP.

OpenHSP
Copyright (C) 1997-2025, Onion Software/onitama, all rights reserved.

These softwares are provided by the copyright holders and contributors "as is" and
any express or implied warranties, including, but not limited to, the implied
warranties of merchantability and fitness for a particular purpose are disclaimed.
		</pre>
		<p>
		For the Linux/Raspberry Pi version, we received great cooperation from <a href="https://github.com/zakki" target="_blank">zakki</a> and <a href="https://github.com/RollMan" target="_blank">yshimmyo</a>.
	We are grateful to the many people who supported the development and gave us their opinions.
	<br>
	The source code can be obtained from the OpenHSP repository.
	</p>
	<ul><pre>
		Github OpenHSP Development
		<a href="http://github.com/onitama/OpenHSP" target="_blank">http://github.com/onitama/OpenHSP</a>
	</pre></ul>


		<!-- Footer -->
		<ul id="FOOTER">
			<a href="https://www.onionsoft.net/" target="_blank" align="right"><img src="image/onimark64.png"></a><br>
			<li><a href="#CONTAINER">Return to the top of this page</a></li>
			<li><a href="https://hsp.tv/" target="_blank">Go to HSPTV page</a></li>
		</ul>
	</div><!-- container -->
</body>

</html>
