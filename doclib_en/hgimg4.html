<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta http-equiv="Content-Language" content="en">
	<meta http-equiv="Content-Style-Type" content="text/css">
	<meta http-equiv="Content-Script-Type" content="text/javascript">
	<meta name="author" content="OpenHSP3 Project">
	<meta name="keywords" content="HSP,HSP3,HotSoupProcessor,HSP3Dish,android,ndk,google">
	<meta name="description" content="HSP3Dish HGIMG4版に関する情報を掲載">
	<link href="../main.css" rel="stylesheet" type="text/css" media="all">
	<title>HGIMG4 Programming Guide</title>
</head>
<body>
	<div id="CONTAINER">
	<!-- ヘッダー -->
	<p id="COPY">HSP : Hot Soup Processor ver3.7 / onion software 1997-2024(c)</p>
	<img src="image/hgimg4ttl.jpg" width="640" height="200" alt="title">
	<h1>HGIMG4 Programming Guide</h1>

	<!-- 目次 -->
	<ol>
		<li><a href="#ABOUT">Introduction</a></li>
		<li><a href="#ENVIROMENT">Operating Environment</a></li>
		<li><a href="#USAGE">How to Use</a></li>
		<li><a href="#RESOURCE">About the Resource Folder</a></li>
		<li><a href="#DLLNOTICE">Notes on DLLs</a></li>
		<li><a href="#COMMANDS">Command List (Main)</a></li>
		<li><a href="#COMMANDS_OBJ">Command List (Object Operations)</a></li>
		<li><a href="#COMMANDS_SUB">Command List (Auxiliary)</a></li>
		<li><a href="#RUNTIME_NOTICE">HGIMG4 Runtime Limitations</a></li>
		<li><a href="#RUNTIME_DX2">About the DirectX Runtime <span class="new">(New!)</span></a></li>
		<li><a href="#UPDATE">Differences from HSP3.6</a></li>
		<li><a href="#DIFF_HGIMG3">Differences from HGIMG3</a></li>
		<li><a href="#INITALIZE">Initialization and Drawing Methods</a></li>
		<li><a href="#3DABSTRACT">Overview of 3D Operations</a></li>
		<li><a href="#2DABSTRACT">Overview of 2D Operations</a></li>
		<li><a href="#ESSPRITE">About Using Standard Sprites <span class="new">(New!)</span></a></li>
		<li><a href="#FONTMES">Font Display</a></li>
		<li><a href="#MODE_OBJ">Object Mode Settings</a></li>
		<li><a href="#TIMER_OBJ">Object Timer</a></li>
		<li><a href="#CAMERA">Camera Settings</a></li>
		<li><a href="#LIGHT">Light Settings</a></li>
		<li><a href="#COLLISION">Collision Group Settings and Collision Detection <span class="new">(New!)</span></a></li>
		<li><a href="#RENDERGRP">Rendering Group Settings</a></li>
		<li><a href="#PHYSICS">Physics Behavior Settings <span class="new">(New!)</span></a></li>
		<li><a href="#MATERIAL">Material Settings</a></li>
		<li><a href="#3DMODEL">Displaying 3D Model Data <span class="new">(New!)</span></a></li>
		<li><a href="#GPBMATERIAL">About Materials in 3D Model Data</a></li>
		<li><a href="#MATERIAL_CHG">Material Changes <span class="new">(New!)</span></a></li>
		<li><a href="#GPBLIGHT">Lighting for 3D Model Data</a></li>
		<li><a href="#SCENE">About Scene Drawing</a></li>
		<li><a href="#TRANSPARENT">About Drawing Transparent Objects <span class="new">(New!)</span></a></li>
		<li><a href="#OBJECTPRM">Object Core Parameters</a></li>
		<li><a href="#OBJECTCLONE">Object Cloning</a></li>
		<li><a href="#VECTOR">Real Number Vector Support Commands</a></li>
		<li><a href="#ROTORDER">About XYZ Rotation Order</a></li>
		<li><a href="#FRAMERATE">Acquiring the Frame Rate</a></li>
		<li><a href="#ANIMATION">Creating Animation Clips</a></li>
		<li><a href="#2DSHADER">Custom Shader Settings for 2D Drawing <span class="new">(New!)</span></a></li>
		<li><a href="#RENDERBUFFER">Rendering Buffer</a></li>
		<li><a href="#EVENT">Event List</a></li>
		<li><a href="#POSTEFFECT">Post Effects <span class="new">(New!)</span></a></li>
		<li><a href="#UVOFFSET">UV Offset/Repeat Settings <span class="new">(New!)</span></a></li>
		<li><a href="#FREEMESH">Creating Free Shapes</a></li>
		<li><a href="#NODEINFO">Acquiring Hierarchy Information <span class="new">(New!)</span></a></li>
		<li><a href="#MEMLIMIT">About Registration Limits <span class="new">(New!)</span></a></li>
		<li><a href="#CUSTOMSHADER">About Using Custom Shaders <span class="new">(New!)</span></a></li>
		<li><a href="#ERRORLOG">Error Log</a></li>
		<li><a href="#NOTICE">Notes on the Current Version</a></li>
		<li><a href="#PACKFILE">PACKFILE Support <span class="new">(New!)</span></a></li>
		<li><a href="#LICENCE">Copyright and License <span class="new">(New!)</span></a></li>
		<li><a href="#ANGLE_LICENCE">Copyright and License of Project Angle</a></li>
		<li><a href="#PRONAMA_LICENCE">Copyright and License of Pro Nama-chan Sample Data</a></li>
	</ol>


	<h2 id="ABOUT">Introduction</h2>
	<p>
	HGIMG4, when used with Hot Soup Processor ver3.7 or later, provides various function extensions related to screen drawing.
	</p>
	<ul>
		Features of HGIMG4<br><br>
	<li>
		Drawing with OpenGL/ES or DirectX9, shader language support
	</li>
	<li>
		Scene management and integrated physics engine (Bullet) support
	</li>
	<li>
		FBX format model file loading, animation support
	</li>
	<li>
		Material and lighting support with custom shaders
	</li>
	<li>
		Font data (TTF) rendering support
	</li>
	<li>
		Support for off-screen rendering and various post-effects
	</li>
	<li>
		Supports operation on Windows, Linux, iOS, Android, and WebGL
	</li>
	<li>
		Same license terms as HSP and HSP3Dish, open source
	</li><br>
	</ul>
	<p>
	<img src="image/sampx.jpg">
	</p>


	<h2 id="ENVIROMENT">Operating Environment</h2>

	<p>
	HGIMG4 allows you to choose between OpenGL and DirectX9 (angle) versions.
	The OpenGL version runs on Windows 7 or later with OpenGL version 3.1 or higher installed.
	The DirectX9 (angle) version runs on Windows 7 or later with the latest DirectX9 runtime installed.
	The DirectX9 (angle) version requires the following DLLs to run.
	(These DLLs are included in the HSP installation folder.
	When distributing applications created by the user, these DLLs must also be distributed.)
	</p>
	<ul><ul><ul>
		d3dcompiler_47.dll	Additional DLL<br>
		libEGL.dll		Additional DLL<br>
		libGLESv2.dll		Additional DLL<br>
	</ul></ul></ul>
	<p>
	These DLLs are not required when using the OpenGL version.<br>
	HGIMG4 consists of the following files:
	</p>
	<ul><ul><ul>
		hsp3gp.exe (OpenGL execution runtime)<br>
		hsp3gpdx.exe (DirectX execution runtime)<br>
<br>
		docs/hgimg4.html (this file)<br>
		common folder (HGIMG4 header files)<br>
		hsphelp folder (HGIMG4 help files)<br>
		runtime folder (HGIMG4 custom runtime)<br>
		sample folder (HGIMG4 sample scripts & data)<br>
	</ul></ul></ul>
	<p>
	HGIMG4 is positioned as an upper runtime of HSP3Dish.
	It includes the functions of HSP3Dish and has high-performance drawing functions.
	It is also possible to run normal HSP3Dish scripts.
	It supports the following environments as a multi-platform:
	</p>
	<ul><ul><ul>
		Windows 7 or later (OpenGL version), XP or later (DirectX9 version)<br>
		Android 5.1 or later<br>
		iOS 10 or later<br>
		Raspberry Pi (raspbian)<br>
		Linux environment supporting SDL/OpenGL<br>
		Various web browsers that support WebGL/html5<br>
	</ul></ul></ul>
	<p>
	In Android and iOS environments, native code can be generated using the same C++ code conversion function as HSP3Dish, and can be registered as a store app.
	</p>


	<h2 id="USAGE">How to Use</h2>

	<p>
	When creating a script using HGIMG4, add the following line to the beginning of the script:
	</p><pre>
	#include "hgimg4.as"
	</pre><p>
	With the above, the functions of HSP will be extended, and you will be able to use the commands described in this reference.
<br>
	First, try running the included sample scripts.
	You should be able to see simple examples of how to use the extended functions.
	The sample scripts are located in sample/hgimg4 and sample/pronama3d under the HSP installation folder.
	</p>


	<h2 id="RESOURCE">About the Resource Folder</h2>

	<p>
	In HGIMG4, when using 3D drawing, necessary resources are loaded from the "res" folder in the same folder as the script.
	The resource files are included in the "sample/hgimg4/res" folder.
	The following files are required for startup, so be sure to include them when creating executable files, etc.
	</p><pre>
	res/shaders folder (including the files inside)
	</pre>
	<p>
	If you are only doing 2D drawing, the shader files in the res/shaders folder are not required.
	<p>


	<h2 id="DLLNOTICE">Notes on DLLs</h2>

	<p>
	HGIMG4 is not an extension plugin using external DLL files.
	It is provided as a runtime file that includes the functions of HSP3DISH.
	Be sure to use a compiler (hspcmp.dll) and script editor that are compatible with the HGIMG4 runtime.<br>
	Also, please use a code generator (hspcmp.dll) that is compatible with the execution runtime for HSP3. (HSP3.6 or later is recommended)<br>
	</p>


	<h2 id="COMMANDS">Command List (Main)</h2>

	<pre>
	setcls mode,color,tex				Screen clear settings
	gpviewport x,y,sx,sy				Viewport settings
	setborder sx,sy,sz,option			Object effective range settings
	gpgetlog var					Get HGIMG4 error log

	gpreset	option					Draw the scene
	gpresetlight p1,p2,p3				Initialize the current light
	gpuselight objid				Register light object
	gpusecamera objid				Switch camera object
	gpusescene sceneid				Switch scene

	gpobjpool start,num				Object ID generation settings
	delobj objid					Discard object
	gpsetprm objid,prmid,value			Set object core parameters
	gpgetprm var,objid,prmid			Get object core parameters
	setobjname objid,"name"				Set the node name of the object
	getobjname var,objid				Get the node name of the object
	setobjmode id,mode,sw				Set object mode
	setcoli id,mygroup,enegroup			Set object collision
	getcoli val,id,distance,startid,objnum		Object collision detection
	getobjcoli var,id,group				Get object collision information
	getnearobj var,id,group,range			Search for the nearest object
	findobj exmode,group				Object search
	nextobj val					Next object search

	gpcolormat var,color,opt			Generate color material
	gptexmat var,"file",opt				Generate texture material
	gpusermat var,"vsh","fsh","defs",color,opt	Generate custom material
	gpmatprm objid,"name",x,y,z			Set material parameters
	gpmatprm1 objid,"name",value			Set material parameters (2)
	gpmatprm4 objid,"name",x,y,z,w			Set material parameters (3)
	gpmatprm16 objid,"name",var			Set material parameters (matrix)
	gpmatprmt objid,"name","filename"		Set material parameters (texture)
	gpmatstate objid,"name","value"			Set material state
	</pre>
	gpbox var,size,color,matobj			Generates a box node
	gpfloor var,sizex,sizey,color,matobj		Generates a floor node
	gpplate var,sizex,sizey,color,matobj		Generates a plate node
	gpload var,"file","name"			Generates a 3D model node
	gpspr var,bufid,celid,gmode			Generates a 2D sprite node
	gpnull var					Generates a null node

	gplight id,opt,range,inner,outer		Sets a light node
	gpcamera id,fov,aspect,near,far			Sets a camera node

	gpclone var,objid				Clones a node
	setobjmode objid,value,mode			Sets the object mode
	setalpha objid,value				Sets the object's transparency (alpha value)
	gplookat objid,x,y,z				Rotates the node towards the specified coordinates

	gppbind objid,mass,friction,option		Sets standard physical properties for a node
	gppset objid,prmid,x,y,z			Sets the physical parameters of a node
	gppapply objid,action,x,y,z			Applies a physical force to a node

	celputm vxpos,vypos,vcelid,bufid,count		Draws cells in bulk
	gpdraw option					Draws all objects in the scene

	gpaddanim objid,"name",start,end,option		Adds an animation clip
	gpact objid,"name",option			Plays/stops an animation clip
	gpgetanim var,objid,index,prmid			Gets animation clip settings
	gpsetanim objid,index,prmid,value		Updates animation clip settings
	</pre>


	<h2 id="COMMANDS_OBJ">Command List (Object Manipulation)</h2>

	<pre>
	getpos id,x,y,z					Gets node coordinates
	setpos id,x,y,z					Sets node coordinates
	addpos id,x,y,z					Adds to node coordinates
	getposi id,x,y,z				Gets node coordinates (integer values)

	getquat id,x,y,z				Gets node rotation (quaternion)
	getang id,x,y,z					Gets node rotation (Euler angles)
	getangr id,x,y,z				Gets node rotation (integer values)
	setang id,x,y,z					Sets node rotation
	setangr id,x,y,z				Sets node rotation (integer values)
	addang id,x,y,z					Adds to node rotation
	addangr id,x,y,z				Adds to node rotation (integer values)

	getscale id,x,y,z				Gets node scale
	setscale id,x,y,z				Sets node scale
	addscale id,x,y,z				Adds to node scale
	getscalei id,x,y,z				Gets node scale (integer values)

	getdir id,x,y,z					Gets node translation
	setdir id,x,y,z					Sets node translation
	adddir id,x,y,z					Adds to node translation
	getdiri id,x,y,z				Gets node translation (integer values)

	getwork id,x,y,z				Gets node work value
	setwork id,x,y,z				Sets node work value
	addwork id,x,y,z				Adds to node work value
	getworki id,x,y,z				Gets node work value (integer values)

	getwork2 id,x,y,z				Gets node work value 2
	setwork2 id,x,y,z				Sets node work value 2
	addwork2 id,x,y,z				Adds to node work value 2
	getwork2i id,x,y,z				Gets node work value 2 (integer values)

	getcolor id,x,y,z				Gets node RGB color
	setcolor id,x,y,z				Sets node RGB color
	addcolor id,x,y,z				Adds to node RGB color
	getcolori id,x,y,z				Gets node RGB color (integer values)
	</pre>


	<h2 id="COMMANDS_SUB">Command List (Auxiliary)</h2>

	<pre>
	selpos id					Sets translation coordinates to MOC information
	selang id					Sets rotation angles to MOC information
	selscale id					Sets scale to MOC information
	seldir id					Sets translation to MOC information

	objsetf3 x,y,z					Sets the selected MOC information
	objaddf3 x,y,z					Adds to the selected MOC information

	objgetfv fv					Gets the selected MOC information
	objsetfv fv					Sets the selected MOC information
	objaddfv fv					Adds to the selected MOC information

	fvset fv,x,y,z					Sets a vector
	fvseti fv,x,y,z					Sets a vector from integer values
	fvadd fv,x,y,z					Adds to a vector
	fvsub fv,x,y,z					Subtracts from a vector
	fvmul fv,x,y,z					Multiplies a vector
	fvdiv fv,x,y,z					Divides a vector
	fvdir fv,x,y,z,type				Gets a calculated vector
	fvmin fv,x,y,z					Vector minimum value
	fvmax fv,x,y,z					Vector maximum value
	fvouter fv,x,y,z				Vector cross product
	fvinner fv,x,y,z				Vector dot product
	fvface fv,x,y,z					Gets the angle from coordinates
	fvunit fv						Normalizes a vector
	fsin fval,rot					Calculates sine
	fcos fval,rot					Calculates cosine
	fsqr fval,prm					Calculates square root
	froti fval,prm					Converts integer angle to decimal value

	fv2str fv					Converts a vector to a string
	str2fv fv,"x,y,z"				Converts a string to a vector
	</pre>


	<h2 id="RUNTIME_NOTICE">HGIMG4 Runtime Restrictions</h2>

	<p>
	HGIMG4 is implemented as an extension of the HSP3Dish runtime.
	It supports all the commands of HSP3Dish, and also has some extensions.
	However, restrictions due to HSP3Dish (inability to use ActiveX objects, various placement objects)
	also occur in the same way. Basic syntax and program control are the same as HSP3.<br>
	For more details on HSP3Dish, please refer to <a href="hsp3dish_prog.htm">HSP3Dish Programming Manual/Basic Specification Guide (hsp3dish_prog.htm)</a>.<br>
	Also, there are some restrictions for each platform, and some functions may not be supported.
	</p>
		<table class="keywordlist" border="1">
		<tr><th>Platform</th><th>Off-screen<br>(Rendering buffer)</th><th>input command support</th></tr>
		<tr><td>Windows</td><td>〇</td><td>〇</td></tr>
		<tr><td>Linux/RaspberryPi</td><td>〇</td><td>〇</td></tr>
		<tr><td>html5(Emscripten)</td><td>×</td><td>×</td></tr>
		<tr><td>android</td><td>〇</td><td>×</td></tr>
		<tr><td>iOS</td><td>×</td><td>×</td></tr>
		</table>
	<p>
	These restrictions may be resolved in future versions, but please understand that this is the current specification.
	</p>


	<h2 id="RUNTIME_DX2">About DirectX Version Runtime</h2>

	<p>
	The HGIMG4 DirectX version runtime is a version that uses Windows DirectX9 functions for drawing.
	It can be expected to work in a wider range of environments compared to the conventional OpenGL version.<br>
	When using the HGIMG4 DirectX version runtime,
	</p><pre>
	#include "hgimg4dx.as"
	</pre><p>
	Please write the above at the beginning of the script.
	</p><pre>
	#include "hgimg4.as"
	</pre><p>
	If you write the above, the conventional OpenGL version runtime will be used.
	There is no difference in the functions that can be used by either runtime.
	However, since the DirectX version runtime is created by imitating the functions of the OpenGL version,
	there may be differences in shader compatibility and operation.
	Also, the size of the library is large, so the file size to be distributed will be larger.
	<br>
	The HGIMG4 DirectX version runtime is based on the source of the ANGLE Project used by Google Chrome, etc.
	When distributing the executable file, "d3dcompiler_47.dll"
	Please note that the three files "libEGL.dll" and "libGLESv2.dll" must be in the same folder as the executable file.
	<br>
	From HSP3.7 beta 7, two types of DirectX version runtimes are now provided: a normal DirectX version runtime and an updated DirectX version runtime.<br>
	The normal DirectX version runtime has excellent drawing speed, but has problems with shader compatibility.<br>
	The updated DirectX version runtime uses the latest library and has excellent shader compatibility, but has problems with drawing speed.
	</p>
		<table class="keywordlist" border="1">
		<tr><th>Runtime</th><th>DirectX version Runtime</th><th>Updated DirectX version Runtime</th></tr>
		<tr><td>Shader compatibility</td><td>△</td><td>〇</td></tr>
		<tr><td>Drawing speed</td><td>〇</td><td>△</td></tr>
		</table>
	<p>
	Both have their advantages and disadvantages, and at present, the user can choose which one to use.
	These specifications may be resolved in future versions, but for the time being, please check the operation and use the optimal one accordingly.<br>
	By default, the normal DirectX version runtime can be used.
	The updated DirectX version runtime must be downloaded and switched separately.
	(This is because they each refer to dlls with the same name, making it difficult to use them at the same time).
	<br>
	If you have HSP3.7 beta 8 or later, you can easily update it with the HSP3 Updater (HSP3Update).
	For details, please refer to <a href="hsp3update.html">"HSP3 Updater (HSP3Update) Manual"</a>.
	</p>


	<h2 id="UPDATE">Differences from HSP3.6 version</h2>

	<p>
	For items added or changed in HSP3.7, please refer to <a href="update37.htm#HGIMG4">"HSP3.7 New Feature Highlights"</a>.
	</p>


	<h2 id="DIFF_HGIMG3">Differences from HGIMG3</h2>

	<p>
	In HGIMG4, there is basically no source code compatibility with HGIMG3.
	However, if you have used HGIMG3, you will be able to transition relatively easily because many of the command systems and systems are inherited.
	</p>
	<ul>
	The main differences from HGIMG3 are as follows:<br><br>
	<li>
	In HGIMG3, models were generated and assigned to objects, but in HGIMG4,
	Objects (node objects) are generated and placed directly.
	</li><li>
	Information such as light reflection, textures, colors, and transparency settings are stored as material objects.
	Generated and assigned to the object.
	</li><li>
	The semi-transparent material settings specified by the setefx command in HGIMG3 are not available.
	</li><li>
	HGIMG4 uses the OpenGL right-handed coordinate system. The positive directions of the Y and Z axes are different from HGIMG3.
	</li><li>
	HGIMG4 internally holds object rotation information in quaternion format.
	It is also possible to give the X, Y, and Z rotation angles in the same way as HGIMG3, but the rotation attitude may be different from HGIMG3.
	</li><li>
	If you want to place multiple copies of the same model, it is recommended to use clones (gpclone command).
	</li></ul>


	<h2 id="INITALIZE">Initialization and Drawing Methods</h2>

	<p>
	Please perform initialization according to the following procedure.
	</p>
	<pre>
		gpreset				; hgimg initialization
	</pre>
	<p>
	The gpreset command is a command that performs a full system initialization.
	Initialization can be performed at any time and as many times as you like.

	After initialization, you can display the registered objects at any time.
	In HGIMG4, drawing is performed in a loop like this:
	</p>
	<pre>
	;------------------------------------------------------------------
	*main
		;	Drawing Main
		;
		redraw 0			; Start drawing (clear screen)

		;	
		;	Perform various drawing
		;	

		redraw 1			; End drawing
		await 1000/60			; Wait for time (60 frames/sec)
		goto *main
	;------------------------------------------------------------------
	</pre>
	<p>
	For the source code related to screen rewriting, please notify the start of drawing with redraw 0,
	Notify the drawing end timing with redraw 1.
	Unlike normal HSP3, the screen is
	Cleared once by specifying "redraw 0".<br>
<br>
	After starting drawing, you can freely write drawing commands such as box, mes, etc.
	After that, you wait for a specified time using the await command. In the case of "await 10",
	a waiting time of at least 10ms is inserted.<br>
<br>
	These rules are the same as in HSP3Dish.
	The drawing commands and specifications available for 2D drawing are also basically the same as in HSP3Dish.
	For details on supported commands, please refer to the <a href="hsp3dish_prog.htm">HSP3Dish Programming Manual/Basic Specifications Guide (hsp3dish_prog.htm)</a>.
	</p>


	<h2 id="3DABSTRACT">Overview of 3D Operation</h2>

	<p>
	HGIMG4 provides a simple and flexible 3D drawing system.
	The important building block is the "node object".

	"Node objects" are the objects to be manipulated by HGIMG4, and are also
	called "nodes" or "objects".
	"Node objects" include all the elements that make up the 3D world, and
	each has its own number (ID).
<br>
	A node object has the following information:
	</p>
<pre>
		Identification number (ID)
		Node name (Name)
		X, Y, Z coordinates (Pos)
		X, Y, Z rotation (Ang)
		X, Y, Z magnification (Scale)
		X, Y, Z movement amount (Dir)
		R, G, B color (Color)
		Work values (X, Y, Z, W) (Work, Work2)
		Material characteristics (MatID)
		Physical characteristics (Physics)
		Camera (viewpoint) settings (Camera)
		Light (light source) settings (Light)
		Emitter (particle generator) settings (Emitter)
</pre>
	<p>
	A "scene" refers to the entire world including multiple "node objects".
	In HGIMG4, "node objects" registered in the "scene" are subject to rendering (drawing).<br>
	A typical program flow is as follows:
	</p>
<pre>
		Reset the entire scene with the gpreset command
			↓
		Register the necessary node objects in the scene
			↓
		Properly set the node object information
			↓
		Draw the scene with the gpdraw command
</pre>
	<p>
	The following commands are available for adding node objects to the scene:
	</p>
	<pre>
		gpbox var,size,color,matobj			Generate a box node
		gpfloor var,sizex,sizey,color,matobj		Generate a floor node
		gpplate var,sizex,sizey,color,matobj		Generate a plate node
		gpload var,"file","name"			Generate a gpb model node
		gpnull var					Generate a null node
		gpclone var,objid				Clone a node
	</pre>
	<p>
	Refer to the help (F1 key) for each command for details.
	The node object ID added to the scene is assigned to the variable specified at the time of generation.
	After that, it is possible to manipulate various information through the node object ID.
<br><br>
	The generated objects are usually placed at coordinates (0,0,0).
	The 3D coordinate system uses a right-handed coordinate system. The larger the Z coordinate value, the closer to the front,
	the larger the Y coordinate, the closer to the ceiling.
<br><br>
	The basic commands for setting the coordinates, angles, and scales of objects are as follows:
	</p>
<pre>
		setpos id,x,y,z		Set X, Y, Z coordinates (Pos)
		setang id,x,y,z		Set X, Y, Z rotation (Ang)
		setangr id,x,y,z	Set X, Y, Z rotation (Ang) (integer value)
		setscale id,x,y,z	Set X, Y, Z magnification (Scale)
</pre>
	<p>
	Specify the node object ID and x, y, z parameters (real values can be used).
	</p>
	<pre>
		Example:
		setpos 3, 5, 1.2, 0.5
	</pre>
	<p>
	In the above example, the object with node object ID 3 is set to the position of coordinates (5.0, 1.2, 0.5).
	The setang command specifies the X, Y, Z angles that the object is facing to perform rotation.
	(The unit of angle is radian (π*2 per revolution))<br>
	Also, the setangr command is available to set the angle in integer values for faster processing.
	In this case, specify in units of one revolution (360 degrees) in 256 steps.
	(0 is 0 degrees, 64 is 90 degrees, 128 is 180 degrees, etc.)<br>
	Commands are also available to set the following information for values:
	</p>
<pre>
		setdir id,x,y,z		Set X, Y, Z movement amount (Dir)
		setcolor id,x,y,z	Set R, G, B color (Color)
		setwork id,x,y,z	Set work value (X, Y, Z)
		setwork2 id,x,y,z	Set work2 value (X, Y, Z)
</pre>
	<p>
	The X, Y, Z movement amount (Dir) is the movement amount that is referenced when the object's automatic movement mode (OBJ_MOVE) is selected.
	R, G, B color (Color) is used to set color information for some objects such as lights.
	Work value and work value 2 are prepared for storing numerical values that users can freely use.
<br><br>
	Not only can you set values directly, but also add〜 commands to add values.

	</p>
<pre>
		addpos id,x,y,z		Add X, Y, Z coordinates (Pos)
		addang id,x,y,z		Add X, Y, Z rotation (Ang)
		addangr id,x,y,z	Add X, Y, Z rotation (Ang) (integer value)
		addscale id,x,y,z	Add X, Y, Z magnification (Scale)
</pre>
	<p>
	These add the specified value to the originally set value.
	add〜 commands have the same types as set〜 commands.
<br><br>
	Also, get〜 commands are available to retrieve the set information.
	</p>
<pre>
		getpos id,x,y,z		Get X, Y, Z coordinates (Pos)
		getscale id,x,y,z	Get X, Y, Z magnification (Scale)
		getdir id,x,y,z		Get X, Y, Z movement amount (Dir)
		getwork id,x,y,z	Get work value (X, Y, Z)
		getwork2 id,x,y,z	Get work2 value (X, Y, Z)
</pre>
	<p>
	These commands specify the variable name of the read destination in x, y, z.
	</p>
	<pre>
		Example:
			; Read the XYZ coordinates of the camera into variables a, b, c
			getpos GPOBJ_CAMERA,a,b,c
	</pre>
	<p>
	In the above example, the X coordinate is assigned to the variable a, the Y coordinate is assigned to the variable b, and the Z coordinate is assigned to the variable c.
	Each is assigned as a real number.<br>
	To obtain parameters as integer values, use the following command.
	</p>
<pre>
		getposi id,x,y,z	Get X, Y, Z coordinates (Pos) as integer values
		getscalei id,x,y,z	Get X, Y, Z magnification (Scale) as integer values
		getdiri id,x,y,z	Get X, Y, Z movement amount (Dir) as integer values
		getworki id,x,y,z	Get work value (X, Y, Z) as integer values
		getwork2i id,x,y,z	Get work2 value (X, Y, Z) as integer values
</pre>
	<p>
	Commands with "i" added at the end are assigned to variables as integer values.
	Can be used when handling coordinates only with integers or when speeding up
	can be done.
	</p>
<pre>
		getquat id,x,y,z	Get node rotation (quaternion)
		getang id,x,y,z		Get node rotation
		getangr id,x,y,z	Get node rotation (integer value)
</pre>
	<p>
	These commands obtain rotation information.
	Specify the variable name of the read destination in x, y, z.<br>
	Care must be taken when acquiring rotation information. In 3D node objects, internal
	Rotation information is stored in quaternion format, and the complete X, Y, and Z rotation angles are
	Difficult to obtain. Therefore, it differs from the X, Y, and Z angles specified by the setang command
	A value may be obtained. Note that this is only a converted value to reproduce a similar posture.
	</p>


	<h2 id="2DABSTRACT">Overview of 2D Drawing</h2>

	<p>
	HGIMG4 has various functions for 2D drawing.
	There are two main categories of 2D drawing methods.
	</p>
	<ul><ul><ul>
	<li>
	Direct drawing
</li><br><p>
		Standard that HSP3Dish supports, such as the mes command and boxf command
		Drawing commands (celput, gcopy, gzoom, etc.) can be used.
		Within the drawing loop from redraw 0 to redraw 1 (drawing unit of one frame)
		Drawing is executed by describing in.
	<li>
	Drawing with sprite objects
</li><br><p>
		You can use sprite objects as one of the objects in the scene
		You can register and manage them. (This is different from standard sprites controlled by commands starting with es_)
		Sprite objects, like 3D node objects,
		An object ID is assigned, and coordinates, angles, scales, etc. can be set.
	</p></ul></ul></ul>
	<p>
	Choose the method that is easy to use as needed.
	For example, when displaying a large 2D image in the background, direct drawing such as the gcopy command is used,
	You can divide the applications into sprite objects, such as enemy characters that appear in large quantities.
<br><br>
	To generate a sprite object, use the gpspr command.
	</p>
	<pre>
		gpspr var,bufid,celid,gmode			Generate a 2D sprite
	</pre>
	<p>
	Specifying the buffer ID of the image loaded by bufid, the ID of the cell by celid, and the synthesis mode by gmode
	Generate a sprite object.
	The generated object ID is assigned to the variable specified by var.
<br><br>
	The generated sprite objects are usually placed at coordinates (0,0).
	2D coordinates are managed by screen coordinates (values that correspond one-to-one with the dots on the screen),
	The upper left corner of the screen is the coordinate (0,0).
<br><br>
	Registered sprite objects are automatically drawn when the scene is drawn with the gpdraw command.
	automatically drawn. At that time, the set X, Y magnification and Z rotation angle are applied.
	Sprite objects can take advantage of various functions such as collision detection (collision) of objects and control by mode.
	You can take advantage of various functions.
	</p>


	<h2 id="ESSPRITE">About using standard sprites</h2>

	<p>
	HGIMG4 allows you to use the standard sprite features of HSP3Dish.
	This is a function separate from the sprite object of HGIMG4.<br>
	Standard sprites are controlled by commands starting with es_. For detailed usage, please refer to the <a href="sprite.html">Standard Sprite Manual</a>.<br>
	In HGIMG4, standard sprites can be drawn to an off-screen buffer.
	However, if the main screen and off-screen sizes (resolution) are different at that time, you need to reset the sprite resolution setting to the off-screen size.
	</p>
	<pre>
		screen 0, 1280, 720, 0
		gpreset
		es_ini
		buffer 1, 640, 360, screen_offscreen + screen_usergcopy
		es_screen
		gsel 0
	</pre>
	<p>
	In the above example, since the main screen is (1280 x 720) and the off-screen is (640 x 360), the es_screen command is executed while the off-screen for drawing is selected to reset the resolution.<br>
	Note that if you reset the resolution with the es_screen command, settings such as the drawing area and border area will also be initialized to the size.
	</p>
	<h2 id="FONTMES">Font Display</h2>

	<p>
	The mes command allows you to display arbitrary strings.
	The font settings specified by the font command are applied when displaying.
	</p>
	<pre>
		font msgothic,30,font_antialias
		mes "こんにちは"
	</pre>
	<p>
	By default, a standard font with a 16-point size is set.
	Please note that separate font files may be required depending on the platform.
	</p>
		<table class="keywordlist" border="1">
		<tr><th>Platform</th><th>Character Code</th><th>Font File</th></tr>
		<tr><td>Windows</td><td>SJIS</td><td>Not required</td></tr>
		<tr><td>Linux/RaspberryPi</td><td>UTF-8</td><td>ipaexg.ttf file is required</td></tr>
		<tr><td>html5(Emscripten)</td><td>UTF-8</td><td>ipaexg.ttf file is required</td></tr>
		<tr><td>android</td><td>UTF-8</td><td>Not required</td></tr>
		<tr><td>iOS</td><td>UTF-8</td><td>Not required</td></tr>
		</table>
	<p>
	Font display, like HSP3Dish, draws font strings on a texture and caches it.
	This method has the advantage of allowing free fonts and characters, but the CPU and memory load will be large when displaying different content over a wide area.
	Displaying values or content that changes every frame will increase the load per frame.
	Also, the load will be large if the font size is large or if a large amount of text is displayed on the screen.<br>
	If font drawing is not required, you can switch to the lightweight drawing format up to HSP3.5 using a system request (however, the characters that can be displayed are limited to English characters only).
		</p><pre>
	setreq SYSREQ_USEGPBFONT,1
		</pre><p>
	As shown above, you can switch to HSP3.5 compatible font display by setting SYSREQ_USEGPBFONT to 1 with a system request. (In this case, you need to prepare a "res/font.gpb" file as font data.)<br>
	Font drawing can be switched by system request at any time.
	</p>


	<h2 id="MODE_OBJ">Object Mode Settings</h2>

	<p>
	Display objects (node objects, sprite objects) have ON/OFF enabled
	mode settings available.
	</p>
	<pre>
		setobjmode id,mode,sw			Set object mode

		ObjID    : Object ID
		mode     : Mode value
		sw       : Setting switch
	</pre>
	<p>
	sw works as follows.
	</p>
	<pre>
		sw = 0 : Add the specified mode value
		sw = 1 : Delete the specified mode value
		sw = 2 : Set only the specified mode value
	</pre>
	<p>
	Select the mode flag value from the following.
	</p>
	<pre>
		Label             |        Content
		--------------------------------------------------------------
		OBJ_HIDE             Hide (remove from screen)
		OBJ_CLIP             Enable 3D clipping
		OBJ_XFRONT           Front attribute (always faces the screen)
		OBJ_WIRE             Draw in wireframe
		OBJ_MOVE             Automatic movement (refer to XYZ movement amount)
		OBJ_FLIP             Flip at border area
		OBJ_BORDER           Enable border area
		OBJ_2D               2D sprite
		OBJ_TIMER            Enable timer
		OBJ_LATE             Drawn later (for semi-transparent objects)
	</pre>
	<p>
	To select multiple items at the same time, use "|" to separate them, like "OBJ_LATE|OBJ_MOVE".
	If you do not specify anything, you can set it to 0 or omit it.
	</p>
	<pre>
		Example:
		setobjmode id, OBJ_MOVE, 0
	</pre>
	<p>
	In the above example, the OBJ_MOVE (automatic movement) setting is added to the object specified by the variable id.
	As a result, this object will automatically move based on the XYZ movement amount (set with the setdir command).
	</p>


	<h2 id="TIMER_OBJ">Object Timer</h2>

	<p>
	Display objects (node objects, sprite objects) can have a timer set to disappear after a specific number of frames.
	</p>
	<pre>
		Example:
		gpsetprm objid, PRMSET_TIMER, 100	; Disappear after 100 frames
		setobjmode objid,OBJ_TIMER		; Enable object timer
	</pre>
	<p>
	First, set the number of frames in the object's core parameter "PRMSET_TIMER",
	and then enable the object timer by adding "OBJ_TIMER" to the mode value.<br>
	After that, the value of the core parameter "PRMSET_TIMER" is decremented by 1 each time it is displayed, and the object disappears when it reaches 0.<br>
	The object timer can also perform similar processing using the event function, but it has the advantage that you can easily set an object to disappear after a specified number of frames.
	</p>


	<h2 id="CAMERA">Camera Settings</h2>

	<p>
	The camera (viewpoint) has the coordinates of the base point for drawing the 3D scene.
	The camera is treated as one of the node objects and has a unique object ID.

	When the scene is reset, the default camera is placed.
	The default camera can be accessed using the GPOBJ_CAMERA macro.
	</p>
	<pre>
		Example:
		setpos GPOBJ_CAMERA, 0,1,5		; Set camera position
	</pre>
	<p>
	In the above example, the default camera is set to the coordinates (0,1,5).
	The camera is the viewpoint coordinates for viewing the 3D scene, and the viewpoint direction is determined by the rotation of the node object.
	The gplookat command can also be used to set the angle for viewing the specified coordinates from the camera.
	</p>
	<pre>
		Example:
		gplookat GPOBJ_CAMERA, 0,1,0		; Set camera focus point
	</pre>
	<p>
	In the above example, the angle for viewing the coordinates (0,1,0) is applied to the camera.
<br><br>
	In addition to the default camera, it is also possible to set and switch between multiple cameras in the scene.
	</p>
	<pre>
		Example:
		gpnull id_camera			; Create a null node
		gpcamera id_camera, 45, 1.5, 0.5, 768	; Set as camera
		gpusecamera id_camera			; Select the camera to use
		setpos id_camera, 0,20,20		; Set camera position
	</pre>
	<p>
	Cameras placed in the scene can be switched using the gpusecamera command.
	By creating your own camera, you can set the FOV (angle of view) and the Z-axis range (Z-clipping range) independently.
	<br>
	Also, by specifying 1 as the camera type value of the gpcamera command, you can set a camera that performs parallel projection (Orthographic).

	</p>


	<h2 id="LIGHT">Light Settings</h2>

	<p>
	Lights (light sources) are the illumination information that can be placed in the 3D scene.
	Lights are treated as one of the node objects and have a unique object ID.
<br><br>
	When the scene is reset, the default directional light is placed.
	The default light can be accessed using the GPOBJ_LIGHT macro.
	</p>
	<pre>
		Example:
		setcolor GPOBJ_LIGHT, 1,1,1		; Set light color
		setdir GPOBJ_LIGHT, 0.5,0.5,0.5		; Set ambient color
	</pre>
	<p>
	In the above example, the default light color is set to (1,1,1).
	The color set to the node with the setcolor command is used as is as the light color.<br>
	Colors can be specified for each RGB with real values from 0 to 1. Since 1 is the maximum brightness,
	in RGB terms, this is (R=255, G=255, B=255).<br>
	With the default light, you can set the ambient (environment) color with setdir.
	In the above example, (R=128, G=128, B=128) is the ambient (environment) color.
	<br>
	With directional lights, changing the light rotation angle changes the direction of illumination.
<br><br>
	It is possible to set lights other than the default light.
	In HGIMG4, the following lights can be used. A maximum of 10 lights for each type can be reflected in 3D objects.
	</p>
		<table class="keywordlist" border="1">
		<tr><th>Type</th><th>Function</th><th>GPU Load</th><th>Referenced Parameters</th></tr>
		<tr><td>Directional Light</td><td>Light source with direction only</td><td>Low</td><td>Rotation (Ang)</td></tr>
		<tr><td>Point Light</td><td>Light source with coordinates and range of influence</td><td>Medium</td><td>Coordinates (Pos), Range (Range)</td></tr>
		<tr><td>Spot Light</td><td>Light source with coordinates, direction, and range of influence</td><td>High</td><td>Coordinates (Pos), Rotation (Ang), Range (Range), Inner (Inner), Outer (Outer)</td></tr>
		</table>
	<p>
<br><br>
	To set a new light, you need to create a light object.
	This is one of the objects placed in 3D space.
	A light object can be created by executing the gplight command on a null node generated with the gpnull command.
	In addition to null nodes, 3D models placed in 3D space can also be created as light objects. In this case, it will be a 3D node with the function of a light.
	</p>
	<pre>
		Example:
		gpnull id_alight			; Create a null node
		gplight id_alight, GPOBJ_LGTOPT_NORMAL	; Register as a light
		gpuselight id_alight			; Set as default light
	</pre>
	<p>
	The gplight command specifies the light type and initializes the light object with parameters.
	</p>
	<pre>
		gplight id,opt,range,inner,outer	Set light node

		id(0)     : Object ID
		opt(0)    : Light generation option
		range(1)  : Influence range parameter
		inner(0.5): Inner attenuation parameter
		outer(1)  : Outer attenuation parameter
	</pre>
	<p>
	The type can be determined by the light generation option.
	</p>
	<pre>
		  opt Value               |  Content
		--------------------------------------------------------------
		  GPOBJ_LGTOPT_NORMAL    Parallel light (directional light)
		  GPOBJ_LGTOPT_POINT     Point light
		  GPOBJ_LGTOPT_SPOT      Spotlight
	</pre>
	<p>
	With the above, an object with the characteristics of light is created.
	The gplight command only sets the function of light to the object.
	The set light must be registered as the current light with the gpuselight command.<br>
	The current light is the light information set when generating 3D objects and materials.
	As long as you only use the default light source, you don't need to be aware of the current light, but
	if you are setting multiple new light sources, you need to set the current light appropriately.
	</p>
	<pre>
		gpresetlight command initializes the current light
			↓
		gpuselight command registers the necessary lights
			↓
		Generates 3D objects and materials (reflecting the current light information)
	</pre>
	<p>
	The gpresetlight command is used to initialize the current light.
	By setting the current light, you can determine the details of the light that models and materials generated afterward will receive.<br>
	In the initial state of a scene, only one directional light can be set. If you want to use multiple lights, point lights, or spotlights, you need to determine the number of current lights in advance using the gpresetlight command.
	</p>
	<pre>
		gpresetlight p1,p2,p3

		p1=1〜9(1) : Number of directional lights
		p2=0〜9(0) : Number of point lights
		p3=0〜9(0) : Number of spotlights
	</pre>
	<p>
	The p1, p2, and p3 parameters specify the maximum number of lights to be used for each light type. At least one directional light must be used.<br>
	Specify point lights and spotlights as needed. Avoid specifying unnecessary lights as they increase the computational load on the GPU.<br>
	After the current light is initialized, it can be registered with the gpuselight command.
	</p>
	<pre>
		gpuselight id,index

		id(0) : ID of the light object to register
		index=0〜9(0) : Index of the light object to register
	</pre>
	<p>
	If you specify the ID of the light object in id, it will be registered in the current light.<br>
	The index value is used when registering multiple lights in the current light. The first light is 0, the second light is 1, and so on. Up to 10 lights can be set for each type.<br>
	By registering in the current light, models and materials generated afterward will be affected by the current light.
	<br>
	The ambient color exists only once in the scene, and the parameters of the light registered as a directional light with index 0 are referenced.
	<br><br>
To change the light settings that are already set for an object, use the setobjlight command.
	</p>
	<pre>
		setobjlight id

		id      : Object ID
	</pre>
	<p>
	This overwrites the current light settings even if the specified object ID already has light settings.<br>
	However, note that the current light settings (number of directional lights, point lights, and spotlights) at the time the 3D model was generated will not be changed. (Be sure to set the same number of lights as the current light contains.)
	</p>
	<p>
	<img src="hsp3dish/light_sample.jpg">
	</p>
	<p>
	Sample light setting examples are included in the sample/hgimg4 folder as light_test1.hsp〜light_test5.hsp, so please check the operation together.
	</p>


	<h2 id="COLLISION">Collision Group Settings and Collision Detection</h2>

	<p>
	By setting a collision group for each object,
	it becomes easier to identify types and allows you to use functions such as collision detection.
	</p>
	<pre>
	setcoli id,mygroup,enegroup		Sets the collision settings for the object

		id       : Object ID
		mygroup  : The group value to which you belong
		enegroup : The group value to be detected for collisions

		Sets collision information for the object.
		For the group value,
		1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768…
		You can select only one. (Up to 32-bit value can be specified)
	</pre>
	<p>
	Objects with collision groups set can use the getcoli command to
	detect collisions within the specified range.
	</p>
	<pre>
	getcoli var,id,distance,startid,numid			Determines object collision

		var      : Variable name to which the result is assigned
		id       : Object ID
		distance : Range to detect collision (real value)
		startid  : Object ID to start detection
		numid    : Number of object IDs to be detected (-1=all)

		Based on the collision information of the specified object,
		searches for the ID of another object with which the object is colliding.
		distance specifies the collision range (radius) as a real value.
		If a collision is detected, the object ID is assigned to the variable.
		If no collision is detected, -1 is assigned.
	</pre>
	<p>
	Collision group settings and collision detection can be used for both 3D node objects and 2D sprite objects.
	However, collisions between 3D node objects and sprite objects are not detected because the coordinate systems are different.<br>
	The getcoli command is a function to detect collisions by detecting whether coordinates overlap in a spherical (or circular) range. It can be checked quickly and easily, but it does not perform accurate contact determination based on the 3D shape.<br>
	However, if you set physical behavior for a 3D object, you can perform accurate contact determination using that information. See the <a href="#PHYSICS">Setting Physical Behavior</a> section for details.
	</p>

	<p>
	The collision group information set for an object can be obtained with the getobjcoli command.
	</p>
	<pre>
	getobjcoli var,id,group				Gets object collision information

		var : Variable name to which the result is assigned
		id(0) : Object ID
		group(0) : Group ID

		Group ID   Content
		---------------------------------------
		  0          Collision group (set with setcoli)
		  1          Collision target group (set with setcoli)
		  2          Rendering group (set with setobjrender)
		  3          Lighting group (set with setobjrender)
		  4          Get bounding sphere size (HGIMG4 only) (*)

		(*) Items are assigned as double values
	</pre>

	<p>
	You can also use the getnearobj command to search for another object closest to the object ID. This can be used to easily check for collisions within a range.
	</p>
	<pre>
	getnearobj var,id,group,range			Searches for the nearest object

		var : Variable name to which the result is assigned
		id(0) : Object ID to search from
		 group(0) : Collision group to search for
		range(10.0): Distance to search (real number)
	</pre>


	<h2 id="RENDERGRP">Rendering Group Settings</h2>

	<p>
	By setting rendering groups, it is possible to group cameras and lights that are referenced for each object.<br>
	The setobjrender command allows you to give settings to objects to show/hide them for each camera.
	You can also set lighting groups, which allows you to control the reflection of lights for each object.
		</p><pre>
	setobjrender id,rendergroup,lightgroup

		id(0) : Object ID
		 rendergroup(1) : Rendering group value
		lightgroup(1) : Lighting group value
		</pre><p>
	A rendering group value is valid if it is the same as the rendering group value of a camera or light.
	Normally, group 1 is set for both the object and the camera. It can be used to disable the display only from a specific camera.<br>
	The lighting group value is used to enable/disable specific lights.
	If it is different from the lighting group value of the light, the light is disabled.<br>
	For each group value, you can combine arbitrary bits from 1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768.
	</p>


	<h2 id="PHYSICS">Setting Physical Behavior</h2>

	<p>
	HGIMG4 integrates physical behavior based on the Bullet Physics Library into 3D node objects.
	By setting physical properties for objects placed in the scene, they will behave according to the laws of physics.
	The physical behavior targets are box nodes (generated with gpbox), floor nodes (generated with gpfloor), plate nodes (generated with gpplate),
	and gpb model nodes (generated with gpload).
<br><br>
	The physical settings are not done at the stage of generating the node object.
	If you want to make physical settings, use the gppbind command.
	</p>
	<pre>
		gppbind objid,mass,friction,option	Sets standard physical properties for nodes

			objid,mass,friction,option
			objid(0)      : Object ID
			mass(1)       : Weight
			friction(0.5) : Coefficient of friction
			option(0)     : Setting options
	</pre>
	<p>
	First, set the basic physical settings using the gppbind command.
	The mass parameter is the weight of the object. The friction parameter is the coefficient of friction. If the value is omitted, the default value is used.
	By setting the weight (mass) to 0, it is set as a static rigid body (it collides but does not move).
	Otherwise, it will fall according to the laws of physics to a place with a floor.<br><br>
	<b>*When setting physical behavior, be sure to create a floor (ground) part.
	By setting standard physical properties for the floor generated by the gpfloor command, you can create a fixed floor surface.
	If the floor does not exist, the object will continue to fall forever.</b><br><br>
	Node objects with physical settings will operate independently thereafter, and coordinate changes such as setpos will be invalid.<br><br>
The option parameter adds options at the time of setting. You can specify the following macros.
	</p>
	<pre>
	  opt value               |  Content
	--------------------------------------------------------------
	  GPPBIND_NOSCALE        Do not reflect the scale of the node in the collision
	  GPPBIND_MESH           Reflect the model of the node as a collision
	</pre>
	<p>
	When you make physical settings for a node object, information for contact determination (collision) is created.<br>
	Box nodes, floor nodes, and plate nodes handle their respective shapes as collisions. If GPPBIND_NOSCALE is specified for the option, the original shape without the scale being reflected becomes the collision.<br>
	3D model nodes, by default, create a sphere that covers the entire model as a collision. However, if GPPBIND_MESH is specified in the option, the shape of the model itself is handled as a collision. However, if a complex model shape is used as a collision, the load on contact determination increases.<br>
	Also, when handling the shape of the model as a collision, it is necessary to consider the concave parts. Concave parts may not be judged correctly.<br>
	The collision is information that is independent of the shape of the model. After the collision is created, note that the scale value of the node is not reflected.
<br><br>
	For more detailed physics settings, use the gppset command.
	</p>
	<pre>
		gppset objid,prmid,x,y,z		Sets the physical parameters of the node
	</pre>
	<p>
	You can specify the item to be set with the parameter prmid.
	The values specified for X, Y, and Z are applied to each item.
	</p>
	<pre>
	        Macro Name                          Content
	    ----------------------------------------------------------------------------
		GPPSET_ENABLE                     X=Physics behavior ON/OFF (0=disabled)
		GPPSET_FRICTION                   X=Friction coefficient, Y=Elasticity setting
		GPPSET_DAMPING                    X=Linear repulsion (0〜1.0), Y=Angular repulsion (0〜1.0)
		GPPSET_KINEMATIC                  X=Kinematic setting ON/OFF (0=disabled)
		GPPSET_ANISOTROPIC_FRICTION       X,Y,Z=Anisotropic friction
		GPPSET_GRAVITY                    X,Y,Z=Gravity
		GPPSET_LINEAR_FACTOR              X,Y,Z=Settings for movement along the vector
		GPPSET_ANGULAR_FACTOR             X,Y,Z=Settings for rotation along the vector
		GPPSET_ANGULAR_VELOCITY           X,Y,Z=Rotational velocity
		GPPSET_LINEAR_VELOCITY            X,Y,Z=Linear velocity
	</pre>
	<p>
	To apply force to an object, use the gppapply command.
	</p>
	<pre>
		gppapply objid,action,x,y,z		Applies physical force to the node
	</pre>
	<p>
	The gppapply command applies the physical force of the vector specified by (x, y, z) to the node.
	The types that can be set with the parameter action are as follows.
	</p>
	<pre>
	        Macro Name                     Content
	    ----------------------------------------------------------------------------
		GPPAPPLY_FORCE               Adds a force to move
		GPPAPPLY_IMPULSE             Applies a momentary impact
		GPPAPPLY_TORQUE              Applies torque (twisting) force
		GPPAPPLY_TORQUE_IMPULSE      Applies torque + impact
		GPPAPPLY_FORCE_POS           Adds a force to move (with coordinate specification)
		GPPAPPLY_IMPULSE_POS         Applies a momentary impact (with coordinate specification)
	</pre>
	<p>
	For objects with physics settings, you can use commands that perform detailed contact determination.<br>
	The gppcontact and gppinfo commands allow you to acquire object physical collision information.
	This makes it possible to investigate the ID of the object in contact with the specified object, the coordinates of the collision, and the strength of the collision, etc.<br>
	If GPPAPPLY_FORCE_POS or GPPAPPLY_IMPULSE_POS is specified, the force is applied using the WORK value (set by the setwork command, etc.) of the model specified by the object ID as coordinate values.
	</p>
	<pre>
		gppcontact var,objid	Creates physical collision information for an object
	</pre>
	<p>
	The gppcontact command creates all the information when the 3D object specified by objid collides with another object.<br>
	The 3D object specified by objid must have its physics settings performed by the gppbind command.
	Also, it is necessary to appropriately set the collision group of the objects to be detected for collisions by the setcoli command.
	The number of collision information created is assigned as an integer value to the variable specified by var. (If an error occurs, a negative value is assigned.)<br>
	Multiple collision information may be created. This is because there may be collisions with multiple objects at the same time. If 0 is assigned to the variable, it indicates that there are no colliding objects.
	The actual collision information can be obtained by the gppinfo command. As collision information, you can acquire the ID of the collided object, the coordinates of the collision, the strength of the collision, etc.<br>
	Collision information is created for each object ID and is retained until the gppcontact command is executed again.
	The gppcontact command is a command for obtaining details of collisions that occur in the process of physical behavior. If you only need to know a simple collision, you can use the getcoli command as a substitute.
Also, please note that collision information is not created in a completely static state (simply touching) because it is based on the information that it collided (dug into another object) when moving with physical behavior.<br>
	</p>
	<pre>
		gppinfo	var,fv,objid,index	Gets the physical collision information of the object
	</pre>
	<p>
	The gppinfo command gets the created physical collision information of the object. The gppcontact command must be executed first.<br>
	The physical collision information of the 3D object specified by objid is assigned to the variables specified by var and fv. The following contents are stored in the variables.
	</p>
	<pre>
	Variable                   Content Assigned
	--------------------------------------------------------------
	var                    Object ID of the collision
        fv(0)                  X coordinate of the collision
        fv(1)                  Y coordinate of the collision
        fv(2)                  Z coordinate of the collision
        fv(3)                  Strength of the collision
	</pre>
	<p>
	If there are multiple collision information detected by the gppcontact command, they are identified by index values starting from 0.
	If there are three collision information, the index values can specify 0 to 2.
	If the process is completed successfully, 0 is assigned to the system variable stat. If an error occurs, a negative value is assigned to the system variable stat.
	</p>
	<p>
	The gppraytest command allows you to examine objects that come into contact with an arbitrary vector (two points in space), rather than contact between objects.
	</p>
	<pre>
		gppraytest var,objid,distance,group	Gets physical collision information on a vector
	</pre>
	<p>
	Using the object with the 3D node specified by objid as a base point, the object ID of the first colliding 3D object is investigated within the distance specified by distance from the direction the object is facing.<br>
	The object specified by objid does not need to have physics settings. Cameras and null nodes are also acceptable.<br>
You can specify the collision group to be targeted for collisions with the group parameter. Please note that the collision settings set for the object specified by objid are not referenced.
If the group parameter is omitted or 0 is specified, all physical setting objects will be targeted.<br>
	The result is assigned to the variable specified by var. A negative value is assigned if any error occurs.
	If there is an object that collides with the line segment, its object ID is assigned. If there is no object that collides, 0 is assigned.
	If there is a collision, detailed information is further stored in the node work values (work, work2) of the object specified by objid.
	Node work values can be obtained by the getwork and getwork2 commands. The contents set for each are as follows.
	</p>
	<pre>
	Node Work Value         Content Set
	--------------------------------------------------------------
	work                   X, Y, Z coordinates where the collision occurred
	work2                  Normal vector X, Y, Z values of the collided face
	</pre>
	<p>
	Collisions with plate nodes (generated by gpplate) may not be judged correctly, so use thick objects (boxes, etc.) when testing for collisions.
	</p>
	<p>
	The gppsweeptest command allows you to investigate physical collision information when a model is moved to a specified vector.
	</p>
	<pre>
		gppsweeptest var,objid,x,y,z,group	Investigates physical collision information when a model is moved to a specified vector
	</pre>
	<p>
	Using the current position of the object with the 3D node specified by the objid parameter as a base point, the object ID of the first colliding 3D object is investigated when moved to the coordinates specified by (X, Y, Z).<br>
A collision detection test is performed based on the physical information set for the object specified by the objid parameter (it is not actually moved).<br>
The group parameter sets whether or not to consider the collision group to be targeted for collisions. If the group parameter is omitted or a value other than 0 is set, the collision group specified by the setcoli command is considered. If 0 is specified, all physical setting objects will be targeted.<br>
<br>
	The result is assigned to the variable specified by var. A negative value is assigned if any error occurs.
	If there is an object that collides with the line segment, its object ID is assigned. If there is no object that collides, 0 is assigned.<br>
If there is a collision, detailed information is further stored in the node work values (work, work2) of the object specified by objid.
	Node work values can be obtained by the getwork and getwork2 commands. The contents set for each are as follows.
	</p>
	<pre>
	Node Work Value         Content Set
	--------------------------------------------------------------
	work                   X, Y, Z coordinates where the collision occurred
	work2                  Normal vector X, Y, Z values of the collided face
	</pre>
	<p>
	The gppraytest command targets all physically set objects for collisions. Collision group settings are not considered.<br>
	Collisions with plate nodes (generated by gpplate) may not be judged correctly, so use thick objects (boxes, etc.) when testing for collisions.
	</p>
	<p>
	<img src="hsp3dish/physics.jpg">
	</p>
	<p>
	Please check the operation together as the physics_1.hsp, physics_2.hsp, physics_3.hsp are included in the sample/hgimg4 folder as samples of contact judgment by physical setting.
	</p>

	<h2 id="MATERIAL">Material Settings</h2>

	<p>
	A material is detailed setting information regarding drawing (rendering).
	It handles a wide range of information, from color information to texture images and shader settings.
	In normal node object generation, a standard material is automatically applied.
	</p>
	<pre>
		Example:
		gpbox id_model, 1, 0xffffff	; Add a white box node
	</pre>
	<p>
	In the example above, a white cube is generated.
	By the user independently generating a material, it becomes possible to set a different texture.
	The commands for generating materials are as follows.
	</p>
	<pre>
		gpcolormat var,color,opt			Generate color material
		gptexmat var,"file",opt				Generate texture material
		gpusermat var,"vsh","fsh","defs",color,opt	Generate custom material
	</pre>
	<p>
	In each case, when a material is generated, an integer value called a material ID is
	assigned to the variable. After that, various settings can be changed via the material ID.
<br><br>
	The gpcolormat command generates a solid color material.
	</p>
	<pre>
		gpcolormat var,color,opt

		var      : Variable name to which the generated material ID is assigned
		color(0) : Material color (24-bit RGB value)
		opt(0)   : Material option value

		Example:
		gpcolormat mat_id,0xff00ff,GPOBJ_MATOPT_NOLIGHT
		gpbox id_model, 1, , mat_id
	</pre>
	<p>
	The above example generates a cube node object with a material whose RGB color is 0xff00ff (purple) and does not perform lighting.
<br><br>
	By specifying the material ID generated by the user when an object is generated,
	it is possible to give it its own material.
	You can change the settings by specifying the following options when generating the material.
	These settings can also be set separately with the gpmatstate command.
	</p>
	<pre>
	        Macro name                Content
	    ----------------------------------------------------------------------------
		GPOBJ_MATOPT_NOLIGHT    Do not perform lighting
		GPOBJ_MATOPT_NOMIPMAP   Do not generate MIPMAP
		GPOBJ_MATOPT_NOCULL     Disable culling
		GPOBJ_MATOPT_NOZTEST    Disable Z test
		GPOBJ_MATOPT_NOZWRITE   Disable Z buffer writing
		GPOBJ_MATOPT_BLENDADD   Set the blend mode to addition
		GPOBJ_MATOPT_SPECULAR   Apply specular reflection when calculating the light source
	</pre>
	<p>
	The gptexmat command generates a material with a texture (image).
	</p>
	<pre>
		gptexmat var,"file",opt

		var     : Variable name to which the generated material ID is assigned
		"file"  : Texture file name to be loaded
		opt(0)  : Material option value

		Example:
		gptexmat id_texmat, "res/qbox.png"	; Create texture material
		gpbox id_model, 1, , id_texmat		; Add box node
	</pre>
	<p>
	The above example generates a material that has qbox.png in the res folder as a texture.<br>
	For texture materials, you can specify the following options in addition to the material options of the gpcolormat command.
	</p>
	<pre>
	        Macro name                Content
	    ----------------------------------------------------------------------------
		GPOBJ_MATOPT_MIRROR     Display as a flipped image
		GPOBJ_MATOPT_CUBEMAP    Set as a cube map
		GPOBJ_MATOPT_NODISCARD  Disable pixel discarding by 留 channel
		GPOBJ_MATOPT_UVOFFSET	Enable specifying UV offset value (u_textureOffset)
		GPOBJ_MATOPT_UVREPEAT	Enable specifying UV repeat value (u_textureRepeat)
	</pre>
	<p>
	The gpusermat command generates a custom material, allowing you to control all rendering using arbitrary shaders.
	This is an advanced extension for those with knowledge of shaders, so it is usually
	not necessary to use.
	</p>
	<pre>
		gpusermat var,"vsh","fsh","defs",color,opt	Generate custom material

		var      : Variable name to which the result is assigned
		"vsh"    : Vertex shader file name
		"fsh"    : Fragment shader file name
		"defs"   : Additional label definitions
		color    : RGB color code
		opt      : Material option specification
	</pre>
	<p>
	When a custom material is generated, you can set the Vector value (X, Y, Z values) to pass to the shader parameters with the gpmatprm command.
	(gpmatprm1, gpmatprm2, gpmatprm4, gpmatprm16, gpmatprmt, and gpmatprmp commands are available depending on the type to be passed)
	</p>
	<pre>
		Example:
		gpmatprm objid,"u_diffuseColor",1,0,0.5 ; Set material parameters
	</pre>
	<p>
	The above example sets a vector value of ( 1.0, 0.0, 0.5 ) to a parameter named u_diffuseColor. This allows you to pass different parameters to the shader for each material.
<br><br>
	

<br><br>
	The gpmatstate command changes the state settings for display via the material ID.
	</p>
	<pre>
		gpmatstate objid,"name","value"		Material state settings
	</pre>
	<p>
	Sets the content specified by value for the item specified by name as a string.
	Please note that all items and settings are done with strings.
	The details of the setting items and contents are as follows.
	</p>
	<pre>
		name             value
	    --------------------------------------------------------------------
		"blend"          Enable/disable blending
	                         (Specify true or false)
		"blendSrc"       Select blend source (see below)
		"blendDst"       Select blend destination (see below)
		"cullFace"       Enable/disable hidden surface removal (culling)
	                         (Specify true or false)
		"cullFaceSide"   Specify the face for hidden surface removal (culling)
		"depthTest"      true or false
	                         (Specify true or false)
		"depthWrite"     Enable/disable Z buffer writing
	                         (Specify true or false)
		"depthFunc"      Select Z value comparison method (see below)

		(*)Strings that can be set with blendSrc, blendDst

		"ZERO"                     Immediate value (0)
		"ONE"                      Immediate value (1)
		"SRC_COLOR"                Writing source color
		"ONE_MINUS_SRC_COLOR"      Writing source color (inverted value)
		"DST_COLOR"                Writing destination color
		"ONE_MINUS_DST_COLOR"      Writing destination color (inverted value)
		"SRC_ALPHA"                Writing source 留
		"ONE_MINUS_SRC_ALPHA"      Writing source 留 (inverted value)
		"DST_ALPHA"                Writing destination 留
		"ONE_MINUS_DST_ALPHA"      Writing destination 留 (inverted value)
		"CONSTANT_ALPHA"           留 fixed value
		"ONE_MINUS_CONSTANT_ALPHA" 留 fixed value (inverted value)
		"SRC_ALPHA_SATURATE"       Writing source 留 inverted value

		(*)Strings that can be set with cullFaceSide

		BACK             Cull the back face
		FRONT            Cull the front face
		FRONT_AND_BACK   Cull both faces

		(*)Strings that can be set with depthFunc

		NEVER            Always reject
		LESS             Permit only when the value is smaller
		EQUAL            Permit only when the values are the same
		LEQUAL           Permit only when the value is the same or smaller
		GREATER          Permit only when the value is greater
		NOTEQUAL         Permit only when the values are not the same
		GEQUAL           Permit only when the value is the same or greater
		ALWAYS           Always permit
	</pre>


	<h2 id="3DMODEL">Displaying 3D Model Data</h2>

	<p>
	You can load and display 3D model data (.gpb file) that has been filed using the gpload command.
	</p>
	<pre>
		Example:
		gpload id_model,"res/duck"		; Load model
	</pre>
	<p>
	The above example loads the duck.gpb file in the res folder.
	At that time, the duck.material file containing the material information is referenced.
	Furthermore, if a texture is required, the image file in the same folder is also loaded.

	The file (.gpb format) for loading with the gpload command is the standard used in gameplay3D
	data format. HGIMG4 provides HGIMG4 tools to generate .gpb format.<br>
	Select "Open HGIMG4 tool" from the "Tools" menu of the HSP script editor, or
	</p>
	<pre>
		gpbconv.exe
	</pre>
	<p>
	to start the tool.
	(Internally calls the command line tool gameplay-encoder.exe)
		</p>
		<p>
		<img src="image/gpbconvert.png">
		</p>
		<p>
	The HGIMG4 tool can convert fbx format files to .gpb format.
	It is also possible to output and confirm the material information (.material) that is read together with the .gpb format.
<br><br>
	Normally, check "Output .material" before converting.<br>
	If you check "Output structure to XML", the parent-child relationship of the nodes will be output as an XML file for confirmation. (.gpb conversion is not performed)<br>
	If you check "Do not modify material name", the material name stored in FBX will be used as is. However, if there is a string containing Japanese, it may not be processed correctly, so normally uncheck it before converting.
<br><br>
	If the FBX contains animations, they will be included in the .gpb format conversion. It supports bone animation and node animation, but not shape animation, so please be careful.<br>
	If the animation data and model data are separated, specify the FBX file containing the animation in the "Animation data" item.<br>
	In this case, the animation data in the FBX file specified in "Animation data" and the model data in the FBX file specified in "Model data" are integrated and the .gpb file is output.<br>
	You can preview the output .gpb file on the "Preview" tab of the HGIMG4 tool.
		</p>
		<p>
		<img src="image/gpbconvert2.png">
		</p>
		<p>
	This is just a simple preview function, but you can check whether the model has been converted correctly, whether the texture and material are reflected correctly, etc.
	(The texture to be loaded must be in the same folder as the .gpb file)
<br><br>
	The fbx format is a standard 3D format used by Autodesk's 3D tools.
	You can use the 3D tool "Unity" to convert and confirm the fbx format.
	For details, please see <a href="hgimg4_unity.html" target="_blank">this page</a>.
	</p>
	<pre>
		<a href="hgimg4_unity.html" target="_blank">HGIMG4 Unity Collaboration Guide</a>
		<a href="hgimg4_unity.html" target="_blank">hgimg4_unity.html</a>
	</pre>
		</p>
		<p>
		<img src="image/hgimg4_unity.jpg">
		</p>
		<p>
	Currently, Blender, Maya, and Unity are the tools that have been confirmed to output fbx and convert gpb.<br>
	Please use the latest version of gpbconv.exe and gameplay-encoder.exe included in the HSP full set.
	If the versions of the converter and the HSP runtime are different, it may not be displayed correctly.
	</p>
	<h2 id="GPBMATERIAL">About 3D Model Data Materials</h2>

	<p>
	The material information (.material file) read along with the .gpb format contains detailed information about the materials (textures) of the model.
	Since the .material file is a text format file, you can view it with a regular text editor or edit its contents as needed.
	<br>
	The .material file can be viewed and edited from the HGIMG4 tool.
	To open the HGIMG4 tool, select "Open HGIMG4 Tool" from the "Tools" menu in the HSP script editor,
	or run "gpbconv.exe" directly.
		</p>
		<p>
		<img src="img/hsp36_material.png">
		</p>
		<p>
	The following is an example of the text content included in the material information.
	If multiple materials are included, the range from "material material_name" followed by "{" to "}" is the setting.
	</p>
	<pre>
	material colored
	{
	    u_worldViewProjectionMatrix = WORLD_VIEW_PROJECTION_MATRIX
	    
	    renderState
	    {
	        cullFace = true
	        depthTest = true
	    }
	    
	    technique
	    {
	        pass 
	        {
	            defines = DIRECTIONAL_LIGHT_COUNT 1
	            vertexShader = res/shaders/colored.vert
	            fragmentShader = res/shaders/colored.frag
	        }
	    }
	}
	</pre>
	<p>
	The renderState settings define the rendering settings for each material.
	</p>
	<pre>
		State Name           Content
		-------------------------------------------------
		cullFace             Backface culling (true/false)
		depthTest            Z-test (true/false)
		depthWrite           Z-write (true/false)
		stencilTest          Stencil test (true/false)
		stencilWrite         Stencil write (true/false)
		blend                Pixel blending settings (true/false)
		blendSrc             Blending source setting (*1)
		blendDst             Blending destination setting (*1)
		depthFunc            Z-test function (*2)

		(*1) Choose from the following
		ZERO / ONE / SRC_COLOR / ONE_MINUS_SRC_COLOR / 
		DST_COLOR / ONE_MINUS_DST_COLOR / SRC_ALPHA / 
		ONE_MINUS_SRC_ALPHA / DST_ALPHA / ONE_MINUS_DST_ALPHA / 
		CONSTANT_ALPHA / ONE_MINUS_CONSTANT_ALPHA / SRC_ALPHA_SATURATE

		(*2) Choose from the following
		NEVER / LESS / EQUAL / LEQUAL / GREATER / GEQUAL / 
		NOTEQUAL / ALWAYS
	</pre>
	<p>
	The pass settings define the shader settings for each material.
	</p>
	<pre>
		Setting Name           Content
		-------------------------------------------------
		defines              Label definition during shader compilation
		vertexShader         Path to the vertex shader file
		fragmentShader       Path to the fragment shader file
	</pre>
	<p>
	The sampler settings define the texture settings for each material.
	</p>
	<pre>
		Setting Name           Content
		-------------------------------------------------
		path                 Path to the image file
		wrapS                Horizontal wrap setting (REPEAT/CLAMP)
		wrapT                Vertical wrap setting (REPEAT/CLAMP)
		mipmap               Mipmap setting (true/false)
		minFilter            Minification filter setting (*1)
		magFilter            Magnification filter setting (*1)

		(*1) Choose from the following
		NEAREST / LINEAR / NEAREST_MIPMAP_NEAREST / 
		LINEAR_MIPMAP_NEAREST / NEAREST_MIPMAP_LINEAR / 
		LINEAR_MIPMAP_LINEAR
	</pre>
	<p>
	In the following example, the string following "path = " is the file path name.
	This indicates that the corresponding texture is read from "res/Metal_Corrogated_Shiny.png".
	</p>
	<pre>
	    sampler u_diffuseTexture
	    {
	        path = res/Metal_Corrogated_Shiny.png
	        wrapS = REPEAT
	        wrapT = REPEAT
	    }
	</pre>
	<p>
	When an FBX texture is converted with gpbconv.exe, the texture file name output to the material information (.material) is unified under the res folder.
	If it cannot be read correctly, check whether the texture (image) file exists in the location specified by the .material file.
	</p>
	<p>
	<img src="image/tamane_samp.jpg">
	</p>


	<h2 id="MATERIAL_CHG">Material Modification</h2>

	<p>
	It is possible to dynamically change the material set for a 3D object.<br>
	To do this, you need to obtain the material from the already generated object ID and directly manipulate that material.
	The gpnodeinfo command obtains various information about 3D models, and an option is available to obtain the material ID.
	</p>
	<pre>
		Example:
		gptexmat id_texmat, "res/qbox.png"
		gpbox id_box, 0.5, -1, id_texmat	; Add a box node
		gpnodeinfo id_boxmat,id_box, GPNODEINFO_MATERIAL	; Get the generated material
	</pre>
	<p>
	In the above example, the ID of the generated material is obtained in id_boxmat.
	After that, you can reset the material information with commands such as gpmatprm, gpmatprmt, and gpmatstate.
	Note that this is different from the material ID indicated by id_texmat created with the gptexmat command.<br>
	The material ID obtained by the gpnodeinfo command is a special ID generated to reference the information within the node.
	If you perform a process that acquires it every frame, a new material ID will be acquired for each frame, so acquire and use the material ID only once at the beginning.<br>
	Even if the material ID obtained by the gpnodeinfo command is discarded by the gpdelobj command, the original material information is maintained, so unnecessary material IDs can be discarded.<br>
	To change the texture image using the acquired material ID, use the gpmatprmt command.
	</p>
	<pre>
		gpmatprmt id,"name","filename"		Set material parameters (texture file)

		id(0)      : Material ID/Object ID
		"name"     : Parameter name
		"filename" : Image file name
		opt(0)     : Material option value

		Example:
		gpmatprmt id_proxymat, , "texture.png"
	</pre>
	<p>
	In the above example, the material texture is replaced with an image with the file name "texture.png".
	(id_proxymat must have the material ID acquired in advance with gpnodeinfo.)<br>
	This allows you to dynamically change the texture set for 3D models, etc. The specified image file is cached, so the file is read only for the first time, and the cached memory data is used thereafter.<br>
	If you want to replace it not with an image file, but with an existing material ID or screen buffer, use the gpmatprmp command.
	</p>
	<pre>
		gpmatprmp id,"name",matobj	Set material parameters (material ID)

		id(0)      : Material ID/Object ID
		"name"     : Parameter name
		matobj(0)  : Material ID

		Example:
		gpmatprmp id_proxymat, , GPOBJ_ID_SRCFLAG+1
	</pre>
	<p>
	In the above example, the material texture is replaced with an image with the rendering buffer ID 1.
	(id_proxymat must have the material ID acquired in advance with gpnodeinfo.)<br>
	If the 3D model has multiple hierarchical structures, you can also specify the node name with the gpnodeinfo command to obtain the material. For details, see the help for the gpnodeinfo command.
	<br>
	Another way is to change the material by rewriting "PRMSET_USEGPMAT", which stores the material ID, using the gpsetprm command that changes the core parameters of the object.<br>
	</p>
	<pre>
		Example:
		gptexmat id_texmat, "res/qbox.png"		; Create texture material
		gpsetprm objid, PRMSET_USEGPMAT, id_texmat	; Change the material
	</pre>
	<p>
	However, note that with this method, 3D models containing multiple materials (3D models generated from gpb files) cannot be rewritten.<br>
	Changing the material is a relatively expensive process because the shader pipeline is changed. Processing that rewrites the material of all objects every frame will lead to a decrease in the frame rate.
	</p>
	<p>
	You can also use the gpsetprmf command to change the texture's filter and wrap mode.
	</p>
	<pre>
		gpmatprmf id,"name","value","prmname"	Detailed texture settings for material

		id(0)       : Material ID/Object ID
		"name"("")  : Setting name
		"value"("") : Value to set
		"prmname"("") : Parameter name

		Example:
		gpmatprmf id_mat, "filter", "nearest"	; Set the texture filter to NEAREST
	</pre>


	<h2 id="GPBLIGHT">3D Model Data Lighting</h2>

	<p>
	Models loaded with the gpload command are based on the shading information recorded in the FBX at the time of conversion.
	Material settings are made.
	In other words, the lighting settings of the model are determined by the .material file.
<br><br>
	If lighting (Directional Light) is set in the conversion source FBX,
	The define definition in the .material file is automatically added.
	To apply lighting to a model that is not lit,
	You need to modify the define definition in the .material file.
	Materials with "DIRECTIONAL_LIGHT_COUNT 1" specified in the define definition of the pass setting section are subject to lighting calculation.
	(If "DIRECTIONAL_LIGHT_COUNT 1" is not specified, no light source calculation will be performed.)
<br><br>
	<p>
	If the scene has light settings made with the gpuselight command,
	When loading a model with the gpload command, the "DIRECTIONAL_LIGHT_COUNT 1" material is internally reset.
	There is no need to make light settings other than "DIRECTIONAL_LIGHT" in the .material file.
	</p>
<br><br>
	Multiple definitions can be described by separating them with the ";" symbol.
	When described as "SPECULAR;DIRECTIONAL_LIGHT_COUNT 1",
	Lighting calculation and specular are applied.
<br><br>
	To apply lighting and specular, add the following definition to the material settings section.
	</p>
	<pre>
            u_inverseTransposeWorldViewMatrix = INVERSE_TRANSPOSE_WORLD_VIEW_MATRIX
            u_cameraPosition = CAMERA_WORLD_POSITION
            u_specularExponent = 50
	    u_directionalLightColor[0] = 1, 1, 1
	    u_directionalLightDirection[0] = 0, 0, -1
	</pre>
	<p>
	These will be the default parameters passed to the shader.
	Add them below the line where "u_worldViewProjectionMatrix" is defined.
	("u_specularExponent" indicates the intensity of the specular reflection.)
	</p>


	<h2 id="SCENE">About Drawing Scenes</h2>

	<p>
	The gpdraw command is used to draw all objects in the scene.
	You can draw only limited items by specifying the following options.
	</p>
	<pre>
	        Macro Name                      Content
	    --------------------------------------------------------------------
		GPDRAW_OPT_OBJUPDATE          Automatic object movement processing
		GPDRAW_OPT_DRAWSCENE          3D scene drawing processing
		GPDRAW_OPT_DRAWSCENE_LATE     3D scene drawing processing (OBJ_LATE)
		GPDRAW_OPT_DRAW2D             2D sprite drawing processing
		GPDRAW_OPT_DRAW2D_LATE        2D sprite drawing processing (OBJ_LATE)
	</pre>
	<p>
	Items with the OBJ_LATE mode attached (including those with translucent alpha values set)
	are drawn after opaque objects, so the items are separated.
	Multiple items can be specified separated by "|".
	</p>
	<pre>
		Example:
		gpdraw GPDRAW_OPT_DRAW2D|GPDRAW_OPT_DRAW2D_LATE
	</pre>
	<p>
	In the example above, only 2D sprite drawing processing and 2D sprite drawing processing (OBJ_LATE) are executed.
	By using this, it becomes possible to display with other drawing commands such as the gcopy command between 3D scene drawing and 2D sprite drawing.
<br><br>
	If the parameter for the gpdraw command is omitted, all items are selected.
	Normally, there is no problem even if you do not specify a parameter.
	Also, if you only use 2D direct drawing commands and object drawing is not required,
	there is no need to write the gpdraw command.
	</p>


	<h2 id="TRANSPARENT">About Drawing Translucent Objects</h2>

	<p>
	You can change the transparency of 2D sprite objects and 3D node objects by setting the 留 channel value.
	</p>
	<pre>
		setalpha ObjectID, 留 value
	</pre>
	<p>
	The 留 value is an integer value from 0 to 255, where 0 is completely transparent and 255 is completely opaque.
	Objects with an 留 value other than 255 (semi-transparent) have their drawing order changed to the front.
	(The same state as when the OBJ_LATE mode is specified)
<br><br>
	In addition, the fade parameter allows you to automatically change the transparency (Alpha value) of the object.
	You can easily achieve fade-out and fade-in effects.
	The fade parameter is set by the gpsetprm command.
	</p>
	<pre>
		Example:
		gpsetprm id, PRMSET_FADE, -4	; Fade out
	</pre>
	<p>
	In the example above, the object indicated by id is faded out by subtracting 4 from the transparency for each frame.
	After fading out, the object is automatically deleted.
	If the value set by gpsetprm is a negative value, it is fade-out,
	and if it is a positive value, it is fade-in.
	The larger the value, the faster the rate of change.
	In either case, addition or subtraction is performed on the object's alpha value (the value set by the PRMSET_ALPHA or setalpha command, from 0 to 255).
	</p>
	<p>
	Drawing processing including semi-transparency (留 channel) has a higher drawing load than normal drawing, so please consider it carefully before applying it.
	For textures that include an 留 channel but are not semi-transparent (only transparent and opaque), pixel cutoff (discarding drawing of pixels with an 留 channel of 0) is applied by default,
	so you can draw objects without being particularly aware of it.
	Conversely, if the 留 channel is 1 to 254 and the back is visible through, it is necessary to sort and draw in order from the back of the Z coordinate. (The drawing sort function based on the Z coordinate is planned to be supported in future versions.)
	</p>


	<h2 id="OBJECTPRM">Object Core Parameters</h2>

	<p>
	Important settings held for each object are called core parameters.
	Core parameters are 32-bit integer values, and can be read and written through the following commands.
	</p>
	<pre>
	gpgetprm var,objid,prmid			Get object core parameter
	gpsetprm objid,prmid,value			Set object core parameter
	gpsetprmoff objid,prmid,value			Set object core parameter (bit deletion)
	gpsetprmon objid,prmid,value			Set object core parameter (bit addition)
	</pre>
	<p>
	Core parameters are 32-bit integer values that manage various information.
	The following items can be specified as the ID of the core parameter.
	</p>
	<pre>
		Macro Name             | Content
		--------------------------------------------------------------
		PRMSET_FLAG            Object registration flag(*)
		PRMSET_MODE            Mode flag value
		PRMSET_ID              Object ID(*)
		PRMSET_ALPHA           Transparency (留 value)
		PRMSET_TIMER           Timer value
		PRMSET_MYGROUP         Own collision group
		PRMSET_COLGROUP        Collision group to detect collisions with
		PRMSET_SHAPE           Shape ID(*)
		PRMSET_USEGPMAT        Material ID
		PRMSET_USEGPPHY        Physics setting ID(*)
		PRMSET_COLILOG         Collision log ID(*)
		PRMSET_FADE            Fade parameter
		PRMSET_SPRID           Source buffer ID (sprite only)
		PRMSET_SPRCELID        Source cell ID (sprite only)
		PRMSET_SPRGMODE        Copy mode (sprite only)

		(*) items are read-only
	</pre>
	<p>
	The gpsetprm command overwrites the core parameter held for each object with the value specified by value.
	For example, you can control fade-in/out by changing the PRMSET_FADE parameter.
	</p>
	<pre>
		Example:
		gpsetprm id, PRMSET_FADE, -4	; Fade out
	</pre>
	<p>
	If you want to turn ON/OFF bits on a bit-by-bit basis instead of overwriting the value, use the gpsetprmon/gpsetprmoff commands.
	</p>
	<pre>
		Example:
		gpsetprmon id, PRMSET_MODE,OBJ_HIDE	; Set only the OBJ_HIDE mode
	</pre>
	<p>
	In the mode flag value set by PRMSET_MODE, the behavior of the object can be set for each bit.
	The setobjmode command is also available for setting and clearing only specific mode flag values.
	For details, see "Object Mode Settings".
	</p>


	<h2 id="OBJECTCLONE">Object Cloning</h2>

	<p>
	The clone function creates a new object with the same settings as an existing object.
	It has the same shape and parameter settings (except for physics settings), but coordinates and angles
	can be set newly.
	This reduces the effort of setting and loading repeatedly when generating multiple identical objects, and also leads to speeding up.
	</p>
	<pre>
		Example:
		gpload id_model,"res/duck"	; Load model
		gpclone i, id_model		; Clone the same object
	</pre>


	<h2 id="VECTOR">Real Number Vector Support Commands</h2>

	<p>
	Real number vector support commands are a group of commands for handling information such as decimal values and vector values.
	The expression FV value appears as a method of storing vectors in variables, but this does not assign a single value like "variable name = 1.0",
	but rather "variable name (0) = X: variable name (1) = Y: variable name (2) = Z" as a real number array variable with
	three elements (X, Y, Z) stored.
<br><br>
	By using FV values, information such as three-dimensional coordinates and vectors can be
	handled relatively easily. In commands that calculate FV values, calculations are performed on three elements simultaneously,
	so processing can be done more simply and faster than calculating for each element.
	</p>
	<pre>
	fvseti fv,x,y,z					Set vector from integer value

		fv      = Variable name to which the FV value is assigned
		(x,y,z) = Integer value

		Assign the integer value specified by (x,y,z) to the FV value as a vector.

	fvset fv,x,y,z					Set vector

		fv      = Variable name to which the FV value is assigned
		(x,y,z) = Real value

		Assign the integer value specified by (x,y,z) to the FV value as a vector.

	fvadd fv,x,y,z					Vector addition
	fvsub fv,x,y,z					Vector subtraction
	fvmul fv,x,y,z					Vector multiplication
	fvdiv fv,x,y,z					Vector division

		fv      = Variable name to which the FV value is assigned
		(x,y,z) = Calculated value (real value)

		Performs operations on the FV value stored in the variable specified by fv and the specified
		decimal value (X, Y, Z) in parallel.

	fvdir fv,x,y,z,type				Get vector with calculation applied

		fv      = Variable name to which the FV value is assigned
		(x,y,z) = Vector value (real value)
		type    = Calculation type of the vector to be acquired

		Based on the FV value (X, Y, Z) stored in the variable specified by fv,
		the calculated value for the vector (X, Y, Z) specified by the real value is assigned to the variable fv as an FV value.

	fvmin fv,x,y,z					Vector maximum value

		fv      = Variable name to which the FV value is assigned
		(x,y,z) = Comparison value (real value)

		Compares the FV value stored in the variable specified by fv with the
		decimal value (X, Y, Z) and assigns the larger value.
		Used to truncate each element of the FV value to the minimum value.

	fvmax fv,x,y,z					Vector minimum value

		fv      = Variable name to which the FV value is assigned
		(x,y,z) = Comparison value (real value)

		Compares the FV value stored in the variable specified by fv with the
		decimal value (X, Y, Z) and assigns the smaller value.
		Used to truncate each element of the FV value to the maximum value.

	fvouter fv,x,y,z				Vector outer product

		fv      = Variable name to which the FV value is assigned
		(x,y,z) = Vector value to be calculated (real value)

		Calculates the outer product of the FV value stored in the variable specified by fv and the vector specified by
		the decimal value (X, Y, Z) and assigns it.

	fvinner fv,x,y,z				Vector inner product

		fv      = Variable name to which the FV value is assigned
		(x,y,z) = Vector value to be calculated (real value)

		Calculates the inner product of the FV value stored in the variable specified by fv and the vector specified by
		the decimal value (X, Y, Z) and assigns it to fv.0.

	fvface fv,x,y,z					Get angle from coordinates

		fv      = Variable name to which the FV value is assigned
		(x,y,z) = X, Y, Z coordinate values (real value)

		Calculates the rotation angle for viewing the specified X, Y, Z coordinates in a straight line from the X, Y, Z coordinates based on the vector (FV value) stored in the variable specified by fv,
		and assigns it.
</pre>
	fvunit fv Vector Normalization

		fv      = Variable name where the FV value is assigned

		Normalizes the vector (FV value) stored in the variable specified by fv.

	fv2str fv Convert Vector to String

		Converts the vector (FV value) stored in the variable specified by fv
		into a string and returns the result to the system variable refstr.

	str2fv fv,"x,y,z" Convert String to Vector

		Reads the string information specified by "x,y,z" as X, Y, Z decimal values
		separated by "," and stores them in the variable specified by fv.

	str2f fval,"val" Convert String to Decimal Value

		Reads the string information specified by "val" as a decimal value and
		stores it in the variable specified by fval.

	f2str val,fval Convert Decimal Value to String

		Converts the decimal value specified by fval into a string and returns the result to the string type
		variable specified by val.
	</pre>
	<p>
	You can set and get object parameters using the variable name to which the FV value is assigned.
	</p>
	<pre>
		Example:
		fvset fv, 1,5,2				; Assign FV value
		selpos GPOBJ_CAMERA			; Select camera coordinate settings
		objsetfv fv				; Set FV value to camera
	</pre>
	<p>
	In the example above, the camera coordinates are set to (1,5,2).
	After selecting the setting destination with sel~ type commands, you can access the selected object with commands such as objsetfv.
	</p>
	<pre>
		selpos id				Select X, Y, Z coordinates (Pos)
		selang id				Select X, Y, Z rotation (Ang)
		selscale id				Select X, Y, Z scale (Scale)
		seldir id				Select X, Y, Z movement (Dir)
		selcolor id				Select R, G, B color (Color)
		selwork id				Select work value (X, Y, Z)
		selwork2 id				Select work2 value (X, Y, Z)
	</pre>
	<p>
	After selecting the setting destination with these sel~ type commands, you can get, set, add, etc. with the following commands.
	</p>
	<pre>
		objgetfv fv				Get the selected MOC information
		objsetfv fv				Set the selected MOC information
		objaddfv fv				Add to the selected MOC information
	</pre>
	<p>
	Real vector support commands are not necessarily for everyone.
	Intermediate and advanced users can choose to use them as appropriate.
	</p>


	<h2 id="ROTORDER">About the rotation order of XYZ</h2>

	<p>
	In HGIMG4, the attitude of an object can be specified by the rotation angles of X, Y, and Z, but
	animation data and internal management use rotation information in quaternion format.<br>
	When acquiring object attitude information as XYZ rotation angles, you can use the getang and getangr commands, but
	since it is difficult to obtain perfect X, Y, Z rotation angles, the X, Y, Z angles specified by the setang command may differ from
	the values obtained. Please note that this is a value converted to reproduce a similar attitude.
	<br>
	When specifying rotation angles, normally the setang command is used, in which case the attitude rotated in the order of X->Y->Z is applied.
	If this is not sufficient, commands with different rotation orders are available, so please make use of them.
	</p><pre>
	setang (Set rotation angle in X->Y->Z order)
	setangy (Set rotation angle in Y->X->Z order)
	setangz (Set rotation angle in Z->Y->X order)
	event_ang (Event change of rotation angle in X->Y->Z order)
	event_angy (Event change of rotation angle in Y->X->Z order)
	event_angz (Event change of rotation angle in Z->Y->X order)
	event_setang (Event setting of rotation angle in X->Y->Z order)
	event_setangy (Event setting of rotation angle in Y->X->Z order)
	event_setangz (Event setting of rotation angle in Z->Y->X order)
	</pre>


	<h2 id="FRAMERATE">Get Frame Rate</h2>

	<p>
	You can get the frame rate at the time of drawing with the getreq command.
	</p>
	<pre>
		getreq fps,SYSREQ_FPS
	</pre>
	<p>
	In the example above, the frame rate (the number of times the screen is drawn per second) is assigned to the variable fps.
	The frame rate is basically determined by the wait time of the await command specified in the drawing loop (redraw 0 to redraw 1 loop).
	In order to keep the frame rate constant and prevent screen flickering (tearing),
	you can specify VSYNC waiting (vertical synchronization waiting).
	</p>
	<pre>
		setreq SYSREQ_VSYNC,1
		gpreset
	</pre>
	<p>
	As above, enable VSYNC waiting with the setreq command before gpreset.
	This will normally result in an operation of 60 frames per second.
	(Even in that case, be sure to include the await command)
	</p>


	<h2 id="ANIMATION">Creating Animation Clips</h2>

	<p>
	Animations read from model data (.gpb files) can be
	extracted and played as multiple clips.
	In order to have multiple animations in a model, it is necessary to prepare
	one long animation registered in advance.
<br><br>
	An animation clip is a set for playing an arbitrary section of animation data
	as an animation.
	You can set a name for the animation clip as a string.
	</p>
	<pre>
		gpaddanim id_model,"run",0,700		; Set "run" clip

	</pre>
	<p>
	In the example above, an animation clip named "run" is set.
	The "run" animation clip is set as an animation that repeats frames from 0 (milliseconds) to 700 (milliseconds).
	The set animation clip can be played with the gpact command.
	(Multiple animation clips can be played simultaneously)
	</p>
	<pre>
		gpact id_model,"run"			; Play "run" clip
	</pre>
	<p>
	The gpact command can control the playback, stop, and pause of the specified animation clip.
	</p>
	<pre>
		gpact objid,"name",option	Play/Stop animation clip

		objid(0)  : Object ID
		"name"(""): Animation clip name
		option(1) : Playback option

		    option value

		        Macro Name              Value          Content
		    -----------------------------------------------
			GPACT_STOP            0           Stop
			GPACT_PLAY            1           Start
			GPACT_PAUSE           2           Pause
	</pre>
	<p>
	Furthermore, the gpgetanim command is available to get the status of the animation clip.
	</p>
	<pre>
		gpgetanim var,objid,index,prmid		Get animation clip settings

		var   : Variable to which information is assigned
		objid(0) : Object ID
		index(0) : Animation clip index (0〜)
		prmid(0) : Parameter ID
	</pre>
	<p>
	Specify the object ID to get the settings for in objid, and specify the animation clip's
	index in index.
	The animation clip index is the number assigned in order to the animation clips
	that the object holds. It is an integer value starting from 0, such as 0,1,2,3...
	If a non-existent index is specified,
	-1 (error) will be assigned to the system variable.
	Specify what kind of information to get with prmid.
	The values that can be specified with prmid are as follows.
	</p>
	<pre>
	        Macro Name                   Value          Content
	    --------------------------------------------------------
		GPANIM_OPT_START_FRAME     0           Start frame (in milliseconds)
		GPANIM_OPT_END_FRAME       1           End frame (in milliseconds)
		GPANIM_OPT_DURATION        2           Playback length (in milliseconds)
		GPANIM_OPT_ELAPSED         3           Elapsed time (in milliseconds)
		GPANIM_OPT_BLEND           4           Blend coefficient (% units)
		GPANIM_OPT_PLAYING         5           Playing flag (0=Stop/1=Play)
		GPANIM_OPT_SPEED           6           Playback speed (% units)
		GPANIM_OPT_NAME            16          Animation clip name
	</pre>
	<p>
	In addition, detailed settings for animation clips can be made with the gpsetanim command.
	</p>
	<pre>
		gpsetanim objid,index,prmid,value	Update animation clip settings

		objid(0) : Object ID
		index(0) : Animation clip index (0〜)
		prmid(0) : Parameter ID
		value(0) : Value to be set (integer value)
	</pre>
	<p>
	Updates the settings of the specified animation clip with the new value specified by value.
	The specification of objid and index is the same as for the gpgetanim command.
	Specify what kind of information to set with prmid. The values that can be specified with prmid are as follows.
	</p>
	<pre>
	        Macro Name                   Value          Content
	    --------------------------------------------------------------
		GPANIM_OPT_DURATION        2           Playback length (in milliseconds)
		GPANIM_OPT_BLEND           4           Blend coefficient (% units)
		GPANIM_OPT_SPEED           6           Playback speed (% units)
	</pre>
	<p>
	This allows you to change the playback speed and playback blend coefficient for each animation clip.
	</p>


	<h2 id="2DSHADER">Custom Shader Settings for 2D Drawing</h2>

	<p>
	Commands that perform direct drawing in 2D, such as gcopy and celput, use the standard
	sprite drawing shader (sprite.frag/sprite.vert).
	By replacing this with another shader created by the user, you can extend the 2D direct drawing independently.
	Assign a shader to the original image buffer used for 2D drawing.
	</p>
	<pre>
		gpusershader "res/shaders/user.vert", "res/shaders/user.frag", ""
		buffer 1,512,512,screen_usergcopy
	</pre>
	<p>
	In the example above, buffer ID 1 is initialized to a size of 512 x 512 dots, and
	the user.vert/user.frag shader is assigned.
	(The user.vert and user.frag shader files must be prepared in advance)
	The gpusershader command is a command for specifying a user-defined shader.
	</p>
	<pre>
		gpusershader "vsh","fsh","defs"		Specify user shader

		"vsh"     : Vertex shader file name
		"fsh"     : Fragment shader file name
		"defs"    : Additional label definitions
	</pre>
	<p>
	The details of OpenGL Shader Language (GLSL) description are not covered here
	because they are extensive. Please refer to separate materials on shaders.
	</p>

	<pre>
	*From HSP3.7β4, the shader parameters used by 2D drawing have been changed for processing optimization.
	If you have already created a custom shader, please note the following points.<br>
	The name of the texture data defined by uniform sampler2D in the shader
	has been changed from "u_texture" to "u_diffuseTexture".<br>
	It has been corrected in the shader files after HSP3.7β4, but
	users who have created custom shader files are kindly requested to make the corresponding changes.
	Even if you are not using a custom shader, if you are using HSP3.7β4 or later,
	please replace the shader files under "res/shaders" with the latest ones before using them.
	</pre>
<h2 id="RENDERBUFFER">Rendering Buffer</h2>

<p>
By specifying options when initializing an image buffer with the buffer command,
it is possible to create an off-screen (non-displayed) rendering buffer.
This allows you to specify the rendering buffer as the drawing destination and create images
before writing them to the main screen, allowing you to construct complex rendering pipelines.
</p>
<pre>
	buffer 1,512,512,screen_offscreen
</pre>
<p>
In the example above, buffer ID 1 is initialized to a size of 512 x 512 dots and set as the
rendering buffer.
(Screens without this setting cannot be used as a drawing destination.)
To actually switch the drawing destination buffer ID, use the gsel command.
Specifying "gsel 1" will cause subsequent drawing commands to be performed on buffer ID 1.
Specifying "gsel 0" will make the main screen the drawing destination.
Frame switching using the redraw command should be performed for each drawing destination buffer.
</p>
<pre>
	gsel 1			; Set drawing destination to buffer ID 1
	redraw 0
	color 255,0,0
	boxf 0,0,100,100
	redraw 1
	gsel 0			; Set drawing destination to main screen
	redraw 0
	gmode 0
	celput 1
	redraw 1
</pre>
<p>
Screen updates are only performed when the main screen (buffer ID 0) is updated.
Until then, you can freely update other rendering buffers.
<br><br>
By using rendering buffers in combination with shader definitions for 2D drawing,
it can be applied to post-effects (effects on the entire screen).
</p>
<pre>
	gpusershader "res/shaders/sprite.vert", "res/shaders/p_sepia.frag", ""
	buffer 1,sx,sy,screen_offscreen + screen_usergcopy

	;	Draw the scene to buffer ID 1
	gsel 1
	redraw 0			; Start drawing
	gpdraw				; Draw the scene
	redraw 1			; End drawing

	;	Draw the effect from buffer ID 1 to the main screen
	gsel 0
	redraw 0			; Start drawing
	pos 0,0:gmode 0
	celput 1
</pre>
<p>
The above example is a part of the post-effect sample (sample/hgimg4/posteffect.hsp).
After drawing 3D etc. to buffer ID 1, the image is drawn to the main screen using the celput command with a shader (sepia filter) that applies effects.
Rendering buffers and shader effects can achieve high-quality results, but the
GPU processing becomes larger and the load increases, which may reduce the frame rate on mobile devices, so please use with caution.
</p>


<h2 id="EVENT">Event List</h2>

<p>
The event list is a function that prepares a set of fixed processes (events) in advance
and applies them to individual objects.
<br><br>
To use the event list, it is broadly divided into:
</p>
<ul><ul><ul><p>
"Creating an event list" and "Applying an event list"
</p></ul></ul></ul>
<p>
There are two stages.
First, "create an event list" to determine specific processes in advance. For example, you can determine detailed actions for each parameter such as "move to the coordinates of ○○" or "add 1 to the X coordinate."
Such processes are called events, and a collection of these is called an event list.
<br><br>
To create an event list, write as follows:
</p>
<pre>
	Example:
		newevent ev1	; Get a new event ID
		event_setpos ev1, 10,20,30
</pre>
<p>
In the example above, an event for setting (10,20,30) as coordinate parameters is created, and the ID is assigned to the variable ev1.
When creating a new event, be sure to get an event ID with the newevent command.
Next, use commands for event registration such as event_setpos to add events to the specified event ID.
Once acquired, the event ID is retained until the scene is reset (gpreset command)
or the event list is deleted by the delevent command.
<br><br>
The event created in this way can be applied to objects at any time.
</p>
<pre>
	Example:
		newevent ev1	; Get a new event ID
		event_setpos ev1, 10,20,30
		; Apply the event of ev1 to the object of objid
		setevent objid, ev1
</pre>
<p>
In this example, the event list of ev1, that is, the process of setting (10,20,30) as coordinates, is applied to the object indicated by objid.
In this way, events can collectively register actions for parameters, and have the function of reflecting them in specific objects.
<br><br>
event_setpos registers events for coordinate setting, but commands for setting other parameters are also available.
</p>
<pre>
	event_setpos eventid, x, y, z
	event_setangr eventid, x, y, z
	event_setscale eventid, x, y, z
	event_setdir eventid, x, y, z
	event_setwork eventid, x, y, z
	event_setwork2 eventid, x, y, z
</pre>
<p>
You can specify the X, Y, Z values to be set for each group as real numbers or integer values.
Also,
</p>
<pre>
	event_setpos eventid, x1, y1, z1, x2, y2, z2
</pre>
<p>
By specifying the range of X, Y, Z in this way, you can automatically generate values within the range specified by random numbers.
</p>
<pre>
	Example:
		newevent ev1	; Get a new event ID
		event_setpos ev1, 10,20,30,30,20,50
</pre>
<p>
In the example above, values up to XYZ = (10 to 30, 20, 30 to 50) are set.
You can also register events that perform addition to parameter values, not just settings.
</p>
<pre>
	event_addpos eventid, x, y, z
	event_addangr eventid, x, y, z
	event_addscale eventid, x, y, z
	event_adddir eventid, x, y, z
	event_addwork eventid, x, y, z
	event_addwork2 eventid, x, y, z
</pre>
<p>
These commands add (X, Y, Z) values to the parameters of a specific group. (Specifying a negative value will result in subtraction.)
<br><br>
In events, you can also add processes according to the passage of time other than parameter settings.
</p>
<pre>
	Example:
		newevent ev1	; Get a new event ID
		event_pos ev1, 20, 0,10,20
</pre>
<p>
In the example above, an event is registered to move to the coordinates (0,10,20) after 20 frames.
The object to which this event is applied will automatically move to the specified coordinates for 20 frames.
<br><br>
The event_wait command is also available to register simple waiting times.
The event_wait event waits for the next event process until the specified number of frames has elapsed.
<br><br>
By registering multiple event_pos events, it is possible to specify the route of movement in detail.
</p>
<pre>
	Example:
		newevent ev1	; Get a new event ID
		event_pos ev1, 20, 10,0,0
		event_wait ev1, 20
		event_pos ev1, 20, 10,10,0
		event_wait ev1, 20
		event_pos ev1, 20, 0,10,0
		event_wait ev1, 20
		event_pos ev1, 20, 0,0,0
		event_wait ev1, 20
</pre>
<p>
In the example above, the movement is performed in the order (10,0,0) → (10,10,0) → (0,10,0) → (0,0,0).
Spline is used by default for interpolation of coordinate movement such as event_pos.
(You can also specify the interpolation method arbitrarily with the command options)
<br><br>
If you want to specify parameters relatively (difference from the original value),
specify the relative specification option.
</p>
<pre>
	Example:
		newevent ev1	; Get a new event ID
		event_pos ev1, 20, 10,10,0, 3
		event_wait ev1, 20
		event_pos ev1, 20, 10,-10,0, 3
		event_wait ev1, 20
		event_pos ev1, 20, 10,10,0, 3
		event_wait ev1, 20
		event_pos ev1, 20, 10,-10,0, 3
		event_wait ev1, 20
</pre>
<p>
In the example above, if the original coordinates are at (0,0,0),
Move in the order (10,10,0) → (20,0,0) → (30,10,0) → (40,0,0).
<br><br>
By combining parameter addition and event_wait events,
It is possible to make continuous parameter changes.
</p>
<pre>
	Example:
		newevent ev1	; Get a new event ID
		event_addpos ev1, 0,1,0
		event_wait ev1, 10
		event_addpos ev1, -1,0,0
		event_wait ev1, 20
</pre>
<p>
In the example above, Y will continue to be added by 1 for the first 10 frames, and then
For 20 frames, the X coordinate will continue to be -1.
Furthermore, to repeat the event process, use the event_jump command.
</p>
<pre>
	Example:
		newevent ev1	; Get a new event ID
		event_addpos ev1, 0,1,0
		event_wait ev1, 20
		event_addpos ev1, 0,-1,0
		event_wait ev1, 20
		event_jump ev1, 0, 100
</pre>
<p>
In the example above, the process of repeatedly adding and subtracting the Y coordinate by 1 every 20 frames
will be performed.
event_jump returns the process to the specified location in the registered event list.
This makes it possible to create an event list that continues to perform specific processes forever.
<br><br>
The event_prmset command registers an event to set various parameters of the object.
You can set the various flags specified by the gpsetprm command from the event.
The specified value is directly set for the following parameter ID.
</p>
<pre>
	Parameter ID   Content
	---------------------------------------
	PRMSET_FLAG            Object registration flag (*)
	PRMSET_MODE            Mode flag value
	PRMSET_ID              Object ID (*)
	PRMSET_ALPHA           Transparency (α value)
	PRMSET_TIMER           Timer value
	PRMSET_MYGROUP         Collision group of its own
	PRMSET_COLGROUP        Collision detection collision group
	PRMSET_SHAPE           Shape ID (*)
	PRMSET_USEGPMAT        Material ID
	PRMSET_USEGPPHY        Physical setting ID (*)
	PRMSET_COLILOG         Collision log ID (*)
	PRMSET_FADE            Fade parameter
	PRMSET_SPRID           Source buffer ID (sprite only)
	PRMSET_SPRCELID        Source cell ID (sprite only)
	PRMSET_SPRGMODE        Copy mode (sprite only)

	(*) Items marked with (*) are read-only
</pre>
<p>
event_prmon, event_prmoff commands are also available for setting and clearing only specific mode flag values. In addition, the event_prmadd command allows addition/subtraction within a specific range.
</p>
	<pre>
		例:
			event_prmon ev1,PRMSET_MODE,OBJ_HIDE
	</pre>
	<p>
	In the above example, only the hide flag is set, and the other flags remain as they are.
	The event_prmoff command clears only the specified flags, while leaving the other flags as they are.
<br><br>
	If an object has executed all the events registered in the event list, it is removed from the registration. (The event list itself remains)
<br><br>
	The event_delobj command registers an event to discard the object itself that is being executed.
	The object is destroyed when this event is executed.
<br><br>
	The event list allows you to manage typical processes that occur in games (such as explosions and missile trajectories) separately in a smart way.
	The event list has a wide range of applications, but on the other hand, there are many types of commands, and it may feel difficult at first. However, if you learn them one by one while using them, you should be able to significantly reduce the effort required to perform the same tasks in scripts.
<br><br>
	Up to four events per object set by the setevent command can be applied simultaneously.
	To prevent multiple events from being executed simultaneously, be sure to specify a fixed slot for registration with the setevent command.
<br><br>
	It is also possible to delete events set for an object using the setevent command. See the command reference for details.
	</p>

	<h2 id="POSTEFFECT">Post Effects</h2>

	<p>
	HGIMG4 provides a module (mod_posteffect.as) for post-effects as standard.<br>
	Post-effects apply effects to the entire screen, and you can select and apply various effects. (Please note that post-effects use an off-screen buffer, so the platforms that can be used are limited.)
	<br>
	The effects currently supported are as follows:
	</p>
		<table class="keywordlist" border="1">
		<tr><th>Post Effect ID</th><th>Value</th><th>Content</th><th>Options</th></tr>

		<tr><td>POSTID_NONE</td><td>0</td><td>None</td><td></td></tr>
		<tr><td>POSTID_SEPIA</td><td>1</td><td>Sepia</td><td></td></tr>
		<tr><td>POSTID_GRAY</td><td>2</td><td>Grayscale</td><td></td></tr>
		<tr><td>POSTID_BLUR</td><td>3</td><td>Blur</td><td>level(4.0)</td></tr>
		<tr><td>POSTID_BLUR2</td><td>4</td><td>Blur (High Quality)</td><td>level(6.0)</td></tr>
		<tr><td>POSTID_MOSAIC</td><td>5</td><td>Mosaic</td><td></td></tr>
		<tr><td>POSTID_CONTRAST</td><td>6</td><td>Contrast</td><td>level(2.0),bright(-0.2)</td></tr>
		<tr><td>POSTID_SOBEL</td><td>7</td><td>Outline Extraction</td><td></td></tr>
		<tr><td>POSTID_CRT</td><td>8</td><td>CRT Style</td><td>Curvature Rate X(0.5), Curvature Rate Y(0.4)</td></tr>
		<tr><td>POSTID_OLDFILM</td><td>9</td><td>Old Film Style</td><td></td></tr>
		<tr><td>POSTID_GLOW</td><td>10</td><td>Glow</td><td>rate(64),bright(0.3)</td></tr>
		<tr><td>POSTID_GLOW2</td><td>11</td><td>Glow (High Quality/Additive)</td><td>rate(128),cutoff(0.5),level(10)</td></tr>
		<tr><td>POSTID_GLOW3</td><td>12</td><td>Glow (High Quality)</td><td>rate(128),cutoff(0.5),level(10)</td></tr>
		<tr><td>POSTID_CUTOFF</td><td>13</td><td>Cutoff</td><td>ratio(0.8)</td></tr>
		</table>
	<p>
	If you are using the post-effect module, be sure to add mod_posteffect.as with the #include command first.
	</p>
	<pre>
		#include "hgimg4.as"		; Use HGIMG4
		#include "mod_posteffect.as"	; Use the post-effect module
	</pre>
	<p>
	This will allow you to use the following commands.
	</p>
	<pre>
		post_reset p1		Initialize post effects
		post_select p1		Specify the post effect ID
		post_setprm p1,p2,p3	Specify post effect options
		post_drawstart 		Start drawing the screen for post effects
		post_drawend		End drawing the screen for post effects
		post_getname p1		Get the post effect name
		post_getmaxid p1	Get the maximum post effect ID

	</pre>
	<p>
	You need to call the post_reset command only once at the beginning to initialize it.<br>
	After that, you can specify the post effect ID using the post_select command to enable the screen effect.
	You can also set the option values for each effect being set using the post_setprm command. (You can specify the parameters in the options item in the table above. The values in parentheses are the default values.)<br>
	When using the post-effect module, use the post_drawstart and post_drawend commands when updating the screen.
	Normally, you update the screen with redraw 0 to redraw 1, but instead use redraw 0 → post_drawstart and redraw 1 → post_drawend.
	Below is an example of applying a very simple post-effect (mosaic).
	</p>
	<pre>
		#include "hgimg4.as"
		#include "mod_posteffect.as"
		
			post_reset			; Initialize post effects
			post_select POSTID_MOSAIC	; Specify the mosaic filter
			setpos GPOBJ_CAMERA, 0,0,5	; Set camera position
			gpbox id_model, 1		; Add a box node
		*main
			post_drawstart			; Start drawing
			color 64,64,64:boxf		; Clear the background
			addang id_model,0,0.02,0.01	; Rotate the node
			gpdraw				; Draw the scene
			post_drawend			; End drawing
			await 1000/60			; Wait time
			goto *main
	</pre>
	<p>
	Post-effects can generate very heavy processing depending on the effect.
	Depending on the performance of the video card (GPU), the frame rate may drop or it may not work correctly, so be careful.
	</p>
	<p>
	The posteffect.hsp is included as a post-effect sample in the sample/hgimg4 folder, so please check the operation together.
	</p>


	<h2 id="UVOFFSET">UV Offset/Repeat Settings</h2>

	<p>
	You can use the GPOBJ_MATOPT_UVOFFSET and GPOBJ_MATOPT_UVREPEAT options when creating a texture material.
	<br>
	This is to add arbitrary values to UV (coordinates where the texture is referenced) values or set the number of repetitions.
	</p>
	<pre>
	gptexmat id_texmat, "res/qbox.png", GPOBJ_MATOPT_UVOFFSET   	; Create texture material
	gpbox id_model, 1 , , id_texmat		; Add a box node
	gpmatprm2 id_model, "u_textureOffset", 0.1, 0.2			; Set UV offset
	</pre>
	<p>
	This makes it possible to display the texture by shifting the coordinates that are originally referenced.
	In the example above, the UV offset is set to add 0.1 to U and 0.2 to V.
	The gpmatprm2 command is a command to update the shader parameters set in the material. Two real numbers are set for the parameter "u_textureOffset".
	UV values are treated as normalized coordinates from 0.0 to 1.0 for the horizontal (U) and vertical (V) coordinates, regardless of the texture resolution. (The part that protrudes from 1.0 is repeated.)<br>
	Similarly, the GPOBJ_MATOPT_UVREPEAT option allows you to set the number of repetitions.
	In this case,
	</p>
	<pre>
	gpmatprm2 id_model, "u_textureRepeat", 2, 2			; Set UV repeat
	</pre>
	<p>
	As above, set the number of repetitions for each UV as two real numbers in the parameter "u_textureRepeat".
	</p>


	<h2 id="FREEMESH">Creating Free Shapes</h2>

	<p>
	You can generate a 3D node object from a custom 3D mesh that defines a free shape as a 3D model.<br>
	You need to construct model information called custom 3D mesh in advance using commands such as gpmeshclear, gpmeshadd, and gpmeshpolygon.
	You can define free and complex shapes instead of simple models such as gpbox and gpplate, but it is considered a function for advanced users because you need to define each vertex coordinate and normal vector.
	Normally, use 3D model data prepared as a .gpb file.<br>
	Custom 3D meshes can be created as follows:
	</p>
	<pre>
	1. Initialize the custom 3D mesh with the gpmeshclear command
	2. Register the necessary vertex information with the gpmeshadd command
	3. Construct a triangular or quadrangular face by combining vertex information with the gpmeshpolygon command
	4. Repeat the above registration for the necessary faces
	</pre>
	<p>
	You can register X, Y, Z coordinates, normal vectors, texture UV coordinates, etc. as vertex information. By setting these appropriately, you can define free shapes.
	</p>
	<pre>
		gpmeshclear			Initialize the custom 3D mesh
	</pre>
	<p>
	The gpmeshclear command initializes the registration information of the custom 3D mesh.<br>
	The actual data registration uses the gpmeshadd and gpmeshpolygon commands.
	</p>
	<pre>
		gpmeshadd var,x,y,z,nx,ny,nz,u,v	Add vertex information to the custom 3D mesh

		var     : Variable name to which the generated mesh vertex ID is assigned
		x(0)    : X coordinate (real number)
		y(0)    : Y coordinate (real number)
		z(0)    : Z coordinate (real number)
		nx(0)   : Normal vector X (real number)
		ny(0)   : Normal vector Y (real number)
		nz(0)   : Normal vector Z (real number)
		u(0)    : Texture vertex coordinate X (real number)
		v(0)    : Texture vertex coordinate Y (real number)
	</pre>
	<p>
	The gpmeshadd command adds vertex information to the custom 3D mesh.<br>
	The vertex information registers X, Y, Z coordinates, normal vectors, and texture UV coordinates as a set.<br>
	The mesh vertex ID registered is assigned to the variable specified by var. The mesh vertex ID is used when constructing a face (triangle, quadrangle).
	If it is vertex information that has already been registered, the previously registered mesh vertex ID is assigned, and it is not registered redundantly. Up to 32767 vertex information can be registered.<br>
	The (X, Y, Z) coordinates indicate the vertices in 3D space. The normal vector (X, Y, Z) indicates the direction (vector) that the vertex is facing, normalized. The normal vector is required when performing light source calculations.<br>
	Texture vertex coordinates (X(u), Y(v)) specify the coordinates referenced when applying a texture. The normalized value is from the origin (0.0, 0.0) to both ends (1.0, 1.0). It is required when applying a texture as a material.<br>
	Register all the necessary vertex information using the gpmeshadd command.<br>
	To actually register a face (triangle, quadrangle) by combining vertex information, use the gpmeshpolygon command.
	</p>
	<pre>
		gpmeshpolygon p1,p2,p3,p4		Adds face information to a custom 3D mesh

		p1(0)   : Mesh vertex ID1
		p2(0)   : Mesh vertex ID2
		p3(0)   : Mesh vertex ID3
		p4(-1)  : Mesh vertex ID4
	</pre>
	<p>
	Combine mesh vertex IDs from the vertex information registered in advance by the gpmeshadd command to construct faces (triangles, quadrilaterals).<br>
	For triangles, specify the mesh vertex IDs for the p1, p2, and p3 parameters, and for quadrilaterals, specify the mesh vertex IDs for the p1, p2, p3, and p4 parameters. The vertices should be arranged in clockwise order for the triangle with p1, p2, and p3. (For quadrilaterals, add the remaining vertex last.)<br>
	<b>The specified coordinates are in a coordinate system where (-1, -1, 0) is the upper left and (1, 1, 0) is the lower right.
Model coordinates are considered based on the size of the coordinate values, not the OpenGL coordinate system.
Also, please note that the vertical 0-1 of the texture (UV) coordinates is reversed.</b>
	<br>
	Register all the necessary face information with the gpmeshpolygon command.
	The data constructed in this way can be registered as a node object with the gpmesh command.
	</p>
	<pre>
		gpmesh var,color,matobj		Generates a 3D mesh node

		var     : Variable name to which the generated object ID is assigned
		color(-1)  : Material color (24bit RGB value)
		matobj(-1) : Material ID
	</pre>
	<p>
	The gpmesh command generates a model using all the registered faces based on the created custom 3D mesh information.<br>
	The ID of the generated object is assigned to the variable specified by var.
	The generated object can be manipulated in the same way as a 3D model loaded with the gpload command.<br>
	The color (material color) of the entire model is specified by a 24-bit RGB value (a value represented by 0xRRGGBB) in the color parameter.
	If the color parameter is omitted, white (0xffffff) is used.<br>
	You can specify a material ID with the matobj parameter.
	Specify this if you want to use a material generated by the user with the gpcolormat command, etc.
	If the matobj parameter is omitted, the standard material is used.<br>
	Custom 3D meshes can be redefined any number of times to register different model shapes.
	</p>
	<p>
	The sample/hgimg4 folder contains freemesh.hsp as a sample of custom 3D meshes, so please check its operation as well.
	</p>


	<h2 id="NODEINFO">Acquiring Hierarchy Information</h2>

	<p>
	3D models loaded with the gpload command have a complex hierarchy (nodes) such as parent-child relationships.
	The gpnodeinfo command is used to obtain and access this hierarchy information.<br>
	With the gpnodeinfo command, it becomes possible to investigate the information of nodes in arbitrary hierarchies and the information of the entire hierarchy.
	</p>
	<pre>
	gpnodeinfo var,objid,option,"name"

	var       : Variable name to which the result is assigned
	objid(0)  : Object ID
	option(0) : Mesh vertex ID1
	name      : Hierarchy node name
	</pre>
	<p>
	Acquire the hierarchy information of the 3D model loaded with the gpload command and assign the result to the variable specified by var.
	Specify individual nodes by specifying the hierarchy of the 3D model specified by objid by name.
	(The names of the hierarchies (node names) are given in advance when creating the 3D model. Use the gptree_get command of the mod_gputil module to get all hierarchies.)
	The result to be assigned can be selected by the option value. The values that can be specified for the option value are as follows.
	</p>
	<pre>
	オプション値          | 取得される内容
	Option Value          | Content to be acquired
	--------------------------------------------------------------
	GPNODEINFO_NODE         Object ID indicating the corresponding node
	GPNODEINFO_MODEL        Object ID indicating the corresponding model node
	GPNODEINFO_NAME         Corresponding node name(*)
	GPNODEINFO_CHILD        Node name of the child the hierarchy has(*)
	GPNODEINFO_SIBLING      Node name of the adjacent node in the same hierarchy(*)
	GPNODEINFO_SKINROOT     Node name that the skin mesh has(*)

	(*) The result string is assigned
	</pre>
	<p>
	If GPNODEINFO_NODE is specified, a special object ID value indicating the hierarchy with the specified name is assigned.
You can use this object ID to get the coordinates and rotation information of each hierarchy, such as getpos, getang, and getquat.
	(This object ID can only be used immediately after being acquired with the gpnodeinfo command. If another hierarchy is acquired with the gpnodeinfo command, the previously acquired object ID becomes invalid.)
	If GPNODEINFO_MODEL is specified, the object ID is acquired only for the hierarchy that has the model to be drawn.
	The GPNODEINFO_CHILD, GPNODEINFO_SIBLING, and GPNODEINFO_SKINROOT options acquire the connections to other hierarchies. This allows you to examine the hierarchy of nodes.
	If the process completes normally, 0 is assigned to the system variable stat. If an error occurs, a negative value is assigned to the system variable stat.
	</p>
	<p>
	The module "mod_gputil.as" for acquiring all hierarchies as strings is provided as standard.
	By using this module, it is possible to acquire the structure of the entire model hierarchy as a string using the gptree_get command.
	The actual model hierarchy acquisition is performed by the gpnodeinfo command in the module.
	</p>
	<pre>
	;	Get all hierarchies as strings
	#include "hgimg4.as"
	#include "mod_gputil.as"
	gpload id_model,"res/tamane2"		; Model loading
	sdim s1,256
	gptree_get s1,id_model
	dialog s1
	</pre>
	<p>
	In the following example, the coordinates (local coordinates) are acquired from the node named "asi_L_" in the model hierarchy of tamane2.gpb.
	If animation is applied, the information after application is acquired.
	</p>
	<pre>
	;	Extract a specific hierarchy as a node
	gpload id_model,"res/tamane2"		; Model loading
	nodename = "asi_L_"
	gpnodeinfo infonode,id_model, GPNODEINFO_NODE, nodename
	if infonode>0 {
		getpos infonode,x,y,z		; Get the coordinates
		mes "XYZ="+x+","+y+","+z
	}
	</pre>
	<p>
	The hierarchy node extracted with the GPNODEINFO_NODE option can acquire hierarchy information with the following commands.
	</p>
	<pre>
	命令     | 取得される内容
	Command     | Content to be acquired
	--------------------------------------------------------------
	getpos     Local coordinates from the root (origin)
	getquat    Local rotation angle from the parent hierarchy (quaternion)
	getang     Local rotation angle from the parent hierarchy (XYZ rotation)
	getscale   Local scale from the parent hierarchy
	getwork    Local coordinates from the parent hierarchy
	</pre>
	<p>
	The hierarchy node extracted with the GPNODEINFO_NODE option can also set hierarchy information with the following commands.
	</p>
	<pre>
	命令     | 設定される内容
	Command     | Content to be set
	--------------------------------------------------------------
	setpos     Local coordinates from the parent hierarchy
	setquat    Local rotation angle from the parent hierarchy (quaternion)
	setang     Local rotation angle from the parent hierarchy (XYZ rotation)
	setscale   Local scale from the parent hierarchy
	</pre>
	<p>
	*Note that the local coordinates of the hierarchy node are different from those obtained with the getpos command.
	</p>


	<h2 id="MEMLIMIT">About the Maximum Number of Registrations</h2>

	<p>
	If the number of objects to be registered or the number of materials is insufficient, it is necessary to set the maximum number separately using the setreq command.
	The following example sets the maximum number of objects to 4096.
	</p>
	<pre>
		setreq SYSREQ_MAXOBJ,4096	; Expand the maximum number of objects
	</pre>
	<p>
	With SYSREQ_MAXMATERIAL, you can set the maximum number of materials.
	This allows you to increase the number of images (textures) handled by the celload command, etc.
	<br>
	The main items that can be set with setreq are as follows. (The values in parentheses are the defaults.)
	</p>
	<pre>
		マクロ名              内容
		Macro Name              Content
		---------------------------------------------------------
		SYSREQ_MAXOBJ         Maximum number of objects (1024)
		SYSREQ_MAXMATERIAL    Maximum number of materials (256)
		SYSREQ_MAXEVENT       Maximum number of events (1024)
		SYSREQ_VSYNC          Enable VSync waiting (0)
		SYSREQ_THROUGHFLAG    Coordinate border processing flag (0)
		SYSREQ_FPS            Frame rate (acquisition only)
	</pre>
	<p>
	In addition, settings items supported by HSP3Dish can also be used.
	</p>


	<h2 id="CUSTOMSHADER">About Using Custom Shaders</h2>

	<p>
	Drawing in HGIMG4 is all done through shaders.
	These are written in OpenGL Shader Language (GLSL), and the files for them are located under "res/shaders".<br>
	The shaders prepared by HGIMG4 are divided into 3D drawing, 2D drawing, and post-effects. Each has a set of vertex shader (.vert) and fragment shader (.frag) files.
	</p>

	<pre>
		ファイル名              用途
		File Name              Use
		---------------------------------------------------------
		sprite                  For 2D drawing (with image)
		spritecol               For 2D drawing (solid color)
		font                    For font drawing (usually not used)
		colored                 For 3D drawing (solid color polygon)
		textured                For 3D drawing (texture polygon)
		terrain                 For terrain drawing (currently not used)
		skybox                  For skybox drawing (currently not used)
		lighting                For lighting calculation (combined with colored, textured, etc.)
		p_で始まるファイル       For post-effects (2D drawing) (files starting with p_)
	</pre>

	<p>
	Normally, these shader names are allocated internally without being conscious of them.
	Custom shader settings are required when using shaders that the user has written independently, rather than standard shaders.<br>
	When performing 3D drawing, you can set custom shaders when creating materials with the gpcolormat and gptexmat commands for single shapes such as boxes and plates generated internally. Use these materials to create shapes with commands such as gpbox and gpplate.<br>
	For details on how to specify custom shaders, see the <a href="#MATERIAL">Material Settings</a> section.
	</p>

	<p>
	For 3D models created by .gpb files, the shader settings are written in the .material file that is loaded as a set.
	</p>

	<pre>
		    technique
		    {
		        pass 
		        {
		            vertexShader = res/shaders/textured.vert
		            fragmentShader = res/shaders/textured.frag
		        }
		    }
	</pre>

	<p>
	You can load custom shaders by rewriting the vertexShader and fragmentShader specifications under the technique/pass item. (If vertexShader/fragmentShader is not specified, it can be added.)
	</p>

	<p>
	Describing custom shaders requires an understanding of the OpenGL Shading Language (GLSL).
	Details of the description are extensive, so they are not explained here.
	Please refer to materials on shaders separately.
	</p>

	<p>
	Normally, "sprite.vert", "sprite.frag", "spritecol.vert", and "spritecol.frag" are used for 2D drawing such as gcopy and celput.
	(These are built into the system, so files under "res/shaders" are not referenced.)<br>
	For settings to replace the shaders used for 2D drawing,
	refer to <a href="#2DSHADER">Custom Shader Settings for 2D Drawing</a>.
	</p>


	<h2 id="ERRORLOG">Error Log</h2>

	<p>
	HGIMG4 outputs a log file that provides hints for understanding the cause of errors or bugs.
	The log file is output as a text file named "hsp3gp.log" in the same folder as the runtime file (hsp3gp.exe).
	Detailed errors and warnings are recorded, such as when loading 3D models, applying animations, or compiling shaders.
	You can set a switch in the sysreq (system request) item to turn the log output On/Off.
	</p>
	<pre>
		setreq SYSREQ_LOGWRITE,0	; Suppress log output
	</pre>
	<p>
	By including the above description, the log file will not be output. By default, log file output is enabled.
	</p>


	<h2 id="NOTICE">Notes on the Current Version</h2>

	<p>
	The following features are not yet implemented. They are planned to be supported in future versions.
	</p>
	<pre>
	・Shadow map support
	・Access to animation data and bone reconnection
	・Detailed settings for collision objects
	・Detailed settings for particles and emitters
	・Bump map, height map, LOD support
	</pre>
	<p>
	HGIMG4 is being developed to make it easier to use and to utilize 3D display in a simpler way.<br>
	HGIMG4 continues to expand its own features in order to utilize advanced technologies such as model data and animation with less data and script.
	It is equipped with OpenGL/DirectX drawing, GLSL shader utilization, a physics engine (Bullet), and an event system.
	It is equipped with powerful systems such as character animation, multi-pass rendering, and post-processing stacks.<br>
	Please look forward to HGIMG4, which continues to evolve towards the new HSP3.7.
	</p>
	<p>
	<img src="image/hgimg4_sample.jpg">
	</p>


	<h2 id="PACKFILE">PACKFILE Support</h2>

	<p>
	It supports reading files packed by the PACKFILE manager ( .dpm files and execution file embedding) in HSP3.7 β2 and later.<br>
	If all data is stored under the "res" folder,
	</p>
	<pre>
		#pack "res/*"
	</pre>
	<p>
	By describing as above and performing Create Executable File automatically ([ctrl] + [F9] key), an executable file containing all data is generated. (If you want to encrypt, use the #epack command.)
	<br>
	The Android version supports reading from data.dpm files and encryption, just like the Windows version.
	Please note that encryption is not yet supported on other platforms.
	</p>


	<h2 id="LICENCE">Copyright and License</h2>

	<p>
	The rights to original software (executable files) created by users using HGIMG4 belong to the user who created them.
	Users are free to exhibit, distribute, and sell original software (executable files) created using HGIMG4 through communication, events, stores, etc.
	No license fee is required.
	HGIMG4 and its source code are subject to the same modified BSD license as the HSP development set.
	<br><br>
	HGIMG4 is developed using multiple libraries.<br>
	When distributing software using HGIMG4,
	please display the following copyright or include a text file.<br><br>
	(In the case of HGIMG4, the document indicated in purple under "Copyright and License",
	In the case of DirectX version HGIMG4 (hgimg4dx), the document indicated in purple under "Project Angle's Copyright and License" must also be presented or included as part of the distribution file.)
	</p>
<pre>
GamePlay3D v3.0.0
http://www.gameplay3d.io/

Bullet Collision Detection and Physics Library
Advanced Micro Devices, Inc.
http://bulletphysics.org

The OpenGL Extension Wrangler Library
Copyright (C) 2002-2007, Milan Ikits <milan ikits[]ieee org>
Copyright (C) 2002-2007, Marcelo E. Magallon <mmagallo[]debian org>
Copyright (C) 2002, Lev Povalahev
All rights reserved.

libpng version 1.6.16, December 22, 2014
Copyright (c) 1998-2014 Glenn Randers-Pehrson
(Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
(Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)

zlib.h version 1.2.8, April 28th, 2013
Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler

OpenHSP
Copyright (C) 1997-2022, ONION Software/onitama.
http://hsp.tv

Disclaimer

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
OTHER DEALINGS IN THE SOFTWARE.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
Neither the name of the Onion Software nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

ソースコード形式かバイナリ形式か、変更するかしないかを問わず、以下の条件を満たす場合に限り、再頒布および使用が許可されます。 

・ソースコードを再頒布する場合、上記の著作権表示、本条件一覧、および下記免責条項を含めること。 
・バイナリ形式で再頒布する場合、頒布物に付属のドキュメント等の資料に、上記の著作権表示、本条件一覧、および下記免責条項を含めること。 
・書面による特別の許可なしに、本ソフトウェアから派生した製品の宣伝または販売促進に、Onion Softwareの名前またはコントリビューターの名前を使用してはならない。 

本ソフトウェアは、著作権者およびコントリビューターによって「現状のまま」提供されており、明示黙示を問わず、商業的な使用可能性、および特定の目的に対する適合性に関する暗黙の保証も含め、またそれに限定されない、いかなる保証もありません。著作権者もコントリビューターも、事由のいかんを問わず、 損害発生の原因いかんを問わず、かつ責任の根拠が契約であるか厳格責任であるか（過失その他の）不法行為であるかを問わず、仮にそのような損害が発生する可能性を知らされていたとしても、本ソフトウェアの使用によって発生した（代替品または代用サービスの調達、使用の喪失、データの喪失、利益の喪失、業務の中断も含め、またそれに限定されない）直接損害、間接損害、偶発的な損害、特別損害、懲罰的損害、または結果損害について、一切責任を負わないものとします。 
</pre>


	<h2 id="ANGLE_LICENCE">Project Angle's Copyright and License</h2>

	<p>
	HGIMG4 DirectX9 version runtime and associated DLLs are based on the
	source of the ANGLE Project. When redistributing,
	include the following copyright notice or "ANGLE Project_LICENSE.txt".<br>
<br>
	The DirectX9 (angle) version runtime was created by zakki-san.
	We would like to thank zakki-san and the many people who provided feedback.
	</p>
<pre>
Copyright (C) 2002-2022 The ANGLE Project Authors. 
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

    Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above 
    copyright notice, this list of conditions and the following
    disclaimer in the documentation and/or other materials provided
    with the distribution.

    Neither the name of TransGaming Inc., Google Inc., 3DLabs Inc.
    Ltd., nor the names of their contributors may be used to endorse
    or promote products derived from this software without specific
    prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
</pre>


	<h2 id="PRONAMA_LICENCE">Copyright and License of Pro-Nama-chan Sample Data</h2>
	<p>
	Please refer to the following for the license of the 3D model (Pro-Nama-chan) used in the sample.
	<pre>
	暮井 慧（プロ生ちゃん） 3D model
	 Pronama LLC
	※詳しくは、 <a href="https://kei.pronama.jp/" target="_blank">https://kei.pronama.jp/</a>
	</pre>
	When using the materials, please be sure to read the "Proseisan" usage guidelines.
	</p>
	<pre>
	Proseisan (Kei Kurei) Usage Guidelines
	<a href="https://kei.pronama.jp/guideline/" target="_blank">https://kei.pronama.jp/guideline/</a>
	</pre>


	<!-- Footer -->
	<ul id="FOOTER">
		<li><a href="#CONTAINER">Return to the top of this page</a></li>
		<li><a href="../index.htm">Return to index</a></li>
	</ul>
	<a href="https://www.onionsoft.net/">
		<img src="onibtn.gif" width="147" height="50" alt="ONION software" id="ONIBTN">
	</a>
</div><!-- container -->
</body>
</html>
